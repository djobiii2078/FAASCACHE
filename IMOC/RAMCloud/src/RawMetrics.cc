/* Copyright (c) 2011 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for
 * any purpose with or without fee is hereby granted, provided that
 * the above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * AUTHORS BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/resource.h>

#include "Common.h"
#include "Cycles.h"
#include "ShortMacros.h"
#include "RawMetrics.h"
#include "MetricList.pb.h"
#include "Segment.h"

namespace RAMCloud {

namespace {
    /// See #metrics.
    RawMetrics _metrics;

    /// Used to compute the ``uptimeTicks'' counter when metrics are retrieved.
    /// This is not a member of RawMetrics:: because the constructor is auto-
    /// matically generated by the rawmetrics.py script and won't know to
    /// initialize this.
    uint64_t ticksAtStartup;
};

/**
 * Stores recovery metrics.
 * This is a pointer for future expansion. It always points to the same RawMetrics
 * object now.
 */
RawMetrics* metrics = &_metrics;

/**
 * This method is invoked from the constructor (which is defined in
 * RawMetrics.in.h).  It initializes a few special "metrics" that contain
 * general information about the server.
 */
void
RawMetrics::init()
{
    Cycles::init();
    clockFrequency = (uint64_t) Cycles::perSecond();
    pid = getpid();
    segmentSize = Segment::DEFAULT_SEGMENT_SIZE;
    ticksAtStartup = Cycles::rdtsc();
}

/**
 * Generate a string that contains a serialized representation of all of the
 * performance counters.
 *
 * \param out
 *      The contents of this variable are replaced with a (binary) string
 *      formatted using Protocol Buffers and MetricList.proto.
 */
void
RawMetrics::serialize(std::string& out)
{
    // First update several counters this class is responsible for that may
    // change between requests. For example, now's a good time to sample any
    // kernel statistics.
    sampleOnDemandMetrics();

    ProtoBuf::MetricList list;
    for (int i = 0; i < numMetrics; i++) {
        MetricInfo info = metricInfo(i);
        ProtoBuf::MetricList_Entry* metric = list.add_metric();
        metric->set_name(info.name);
        metric->set_value(*info.value);
    }
    out.clear();
    list.SerializeToString(&out);
}

/**
 * Update any changing counters the RawMetrics class is responsible for.
 * It is intended to be lazily called in the serialize() method.
 */
void
RawMetrics::sampleOnDemandMetrics()
{
    // Get total user and system cpu time as recorded by the kernel. Use ticks
    // for consistency with other time counting metrics.
    struct rusage ru;
    int r = getrusage(RUSAGE_SELF, &ru);
    if (r != 0) {
        RAMCLOUD_DIE("getrusage failed: %s", strerror(errno));
    }
    uint64_t ticksPerUsec = clockFrequency / 1000000;
    processSystemTicks = timevalToMicroseconds(&ru.ru_stime) * ticksPerUsec;
    processUserTicks = timevalToMicroseconds(&ru.ru_utime) * ticksPerUsec;

    // Knowing exactly how long a server has been running is always useful
    // and provides a convenient time delta when one takes the difference of
    // two ClusterMetrics.
    uptimeTicks = Cycles::rdtsc() - ticksAtStartup;
}

}  // namespace RAMCloud

// This file is automatically generated from scripts/rawmetrics.py; it defines
// the metricInfo method.
#include "RawMetrics.in.cc"
