/*
 * Contains the main B+ tree implementation used for RAMCloud
 * Indexing operations.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef _BTREE_H_
#define _BTREE_H_

#include <assert.h>

#include "Buffer.h"
#include "Object.h"
#include "ObjectManager.h"
#include "PerfStats.h"

namespace RAMCloud {

// Nodes in the B+ tree are stored as RAMCloud objects with the key being a
// 64-bit number. This number increases monatonically with every node
// creation/split, starting at ROOT_ID so long as the tree is never emptied.
// If emptied, the NodeId resets.
typedef uint64_t NodeId;
#define INVALID_NODEID (1)
#define ROOT_ID 100

/**
 * This structure stores a single mapping between a secondary index
 * key and a single primary key hash in the indexlet Btree and is used to pass
 * information into and out of the Btree API for inserts and finds.
 */
struct BtreeEntry {
    /// Index secondary key
    const void *key;

    /// Length of index secondary key.
    uint16_t keyLength;

    /// Primary key hash of the object the index key points to.
    uint64_t pKHash;

    BtreeEntry (const void *key, uint16_t keyLength, uint64_t pKHash)
        : key(key)
        , keyLength(keyLength)
        , pKHash(pKHash)
    {}

    BtreeEntry (const char *key, uint64_t pKHash)
        : key(key)
        , keyLength(uint16_t(strlen(key)))
        , pKHash(pKHash)
    {}


    BtreeEntry()
        : key(NULL)
        , keyLength(0)
        , pKHash(0)
    {}

    BtreeEntry& operator =(const BtreeEntry& other) {
        this->keyLength = other.keyLength;
        this->pKHash = other.pKHash;
        key = other.key;
        return *this;
    }

    bool operator ==(const BtreeEntry& other) const {
        return (keyLength == other.keyLength) &&
                (pKHash == other.pKHash) &&
                (0 == memcmp(key, other.key, keyLength));
    }

    bool operator!=(const BtreeEntry& other) const {
        return !(operator==(other));
    }

    /// returns a string representation of the entry, useful for debugging.
    std::string toString() {
        std::ostringstream out;
        out << " ( pKHash: " << pKHash << " keyLength: " << keyLength
                << " key: "
                << std::string((const char*) key, keyLength).c_str()
                << " )";
        return out.str();
    }
};

/**
 * This class implements a B+ tree that stores variable length Secondary Key to
 * Primary Key Hash mappings used in RAMCloud indexing operations. To support
 * crash recovery, the B+ tree's nodes are stored as RAMCloud Objects in a
 * system generated table with a 64-bit number as a key.
 */
class IndexBtree {
    /**
     * This class implements a standard (n, m) B+ tree that maps variable
     * length secondary key blobs to primary key hashes for retrieval in
     * RAMCloud index operations. The property (n, m) means the smallest
     * non-root node in the system can only have n entries and the largest
     * node in the system can be up to n/m entries at most. In our case,
     * n = mininnerslot  and m = innerslotmax. This B+ does caolesce and
     * rebalance nodes to maintain this invariant.
     *
     * As with most B+ trees, there are leaf nodes which contain n keys/data
     * and inner nodes that contain the n keys and n + 1 pointers to other
     * nodes. However, unlike most trees, the key and data are one and the same
     * in this case since it is desired to sort by not only the secondary key
     * but also the pKHash number. Thus, the inner nodes in this B+ also
     * contain data as well the keys. This key+data combination is called
     * an Entry.
     *
     * The B+ tree is organized such that the root is always in a fixed location
     * after a recovery. This is achieved by storing the B+ nodes as RAMCloud
     * objects so that the nodes are automatically recovered during a crash
     * and the root node is always stored with the same RAMCloud object key
     * (ROOT_ID) so it is possible to continue using the B+ tree after recovery.
     * One important note is that the nextNodeId variable is recovered elsewhere
     * in the system and it is CRUCIAL to set properly after a recovery. The
     * reason is because the system-generated RAMCloud Object Keys for the Nodes
     * depends on that variable. If set incorrectly, new nodes could overwrite
     * live data.
     *
     * One more property worth mentioning is that the entries stored in inner
     * nodes slot refer to the rightmost key of the subtree where the subtree
     * root is the child pointer at that position. This allows the B+ tree to
     * store n entries to n + 1 child pointers as the last entry in the B+
     * tree can be used as a pivot point to choose between the final child or
     * the second last child.
     *
     * The properties of the B+ tree is summarized below
     *      - Keys in the system are (Secondary Key Blob) to (Primary Key Hash)
     *        mappings called Entry's
     *      - Smallest non-Root node contains at least mininnerslots entries
     *      - Largest node contains at most innerslotmax entries
     *      - Nodes are allocated as RAMCloud objects
     *      - Keys are sorted within a nodes
     *      - Inner Node Keys refer to the rightmost leaf key when traversing
     *        the subtree NodeId pointer.
     */

PUBLIC:
#if (TESTING == false)
    /// The maximum number of secondary key to primary key hash pairs that can
    /// be stored in a leaf node.
    static const uint16_t leafslotmax = 16; // Do not set to 32 see RAM-715
#else
    /// Tests run exponentially slower as this value increases since tests need
    /// to build a B+ tree at least 3 levels deep to reach all corner cases and
    /// this value controls the fanout. Hence a smaller value is defined for
    /// testing
    static const uint16_t leafslotmax = 8;
#endif

    /// The maximum number of secondary key to primary key hash pairs that can
    /// be stored in an inner node; It is the equal to leafslotmax, but it can
    /// be different.
    static const uint16_t innerslotmax = leafslotmax;

    /// The minimum number of secondary key to primary key hashes stored in a
    /// leaf. The only node that can violate this invariant is the root
    static const uint16_t minleafslots = (leafslotmax / 2);

    /// The minimum number of secondary key to primary key hashes stored in a
    /// inner node. The only node that can violate this invariant is the root
    static const uint16_t mininnerslots = (innerslotmax / 2);

    //TODO(syang0) File a bug on commit. This appears to work for testing,
    //but not in production....
    /// Debug parameter: Enables expensive and thorough checking of the B+ tree
    /// invariants after each insert/erase/find operation.
    static const bool selfverify = false;

    /// Enables the use of binary searching to find entries within a Node.
    /// A value of false will result in linear searching instead.
    static const bool useBinarySearch = true;

    /**
     * A small struct containing basic statistics about the B+ tree.
     */
    struct tree_stats {
        /// Number of items in the B+ tree
        uint64_t itemcount;

        /// Number of leaves in the B+ tree
        uint64_t leaves;

        /// Number of inner nodes in the B+ tree
        uint64_t innernodes;

        /// Base B+ tree parameter: The number of key/data slots in each leaf
        static const uint16_t leafslots = leafslotmax;

        /// Base B+ tree parameter: The number of key slots in each inner node.
        static const uint16_t innerslots = innerslotmax;

        inline tree_stats()
            : itemcount(0),
              leaves(0),
              innernodes(0)
        {}

        /// Return the total number of nodes
        inline uint64_t nodes() const {
            return innernodes + leaves;
        }

        /// Return the average fill of leaves
        inline double avgfill_leaves() const {
            return static_cast<double>((itemcount) / (leaves * leafslots));
        }
    };

PRIVATE:
    /// Keeps track of statistics about the B+ tree. The correctness of
    /// the stats are not crucial to the operation of the B+
    /// tree and they are currently not persisted across recoveries and
    /// migrations. Currently they are used in debug testing only.
    tree_stats  m_stats;

    /// tableId of the RAMCloud table that this logical tree uses to
    /// as a backing table to store its nodes.
    uint64_t treeTableId;

    /// Pointer to the objectManager instance that corresponds to a specific
    /// MasterService
    ObjectManager* objMgr;

    /// this acts as the primary key for the objects representing the nodes
    /// of the tree. In particular, it represents the next nodeId that can
    /// be used to create a new node/RamCloud object. This number increases
    /// monatonically unless the tree is emptied, in which case it resets to
    /// the initial value of ROOT_ID. It is crucial upon recovery or migration
    /// to set this number to the highest nodeId in the recovery/migration
    /// otherwise the Btree will start overwriting nodes!
    uint64_t nextNodeId;

    /// NodeId corresponding to the root of the tree. This corresponds to the
    /// primary key of the RamCloud object storing the root of the tree.
    NodeId m_rootId;

    /// Global buffer that contains all the log records including necessary
    /// tombstones pertaining to the current insertion/deletion operation.
    /// At the end of the operation, this buffer is merely copied to the log.
    Buffer logBuffer;

    /// Number of log entries in the logBuffer. This is useful when atomically
    /// flushing the buffer to the log.
    uint32_t numEntries;

    /// Map between nodeId and offset in #logBuffer. This is useful when the
    /// parent needs to occasionally read its child before its child has been
    /// written to the log. Since, the object would have only been written to
    /// #logBuffer, we need to know the offset in it. This is currently only
    /// used during an erase sequence. Nodes read from cache should be
    /// considered read-only since any modifications will trash the logBuffer.
    std::map<NodeId, uint32_t> cache;

    DISALLOW_COPY_AND_ASSIGN(IndexBtree);

PRIVATE:
    /**
     * Implements the base class for the inner and leaf nodes of the B+ tree.
     * The main responsibility of the base class is to abstract the complexity
     * of storing variable-sized blobs in a RAMCloud Buffer and provide a
     * vector-like API with set/insert/get/erase operations. The semantics of
     * the data and how to arrange the items within the logical array are
     * determined by the IndexBtree class.
     *
     * Nodes use Buffers to keep track of variable-sized secondary keys, which
     * is also convenient since RAMCloud Objects are serialized to Buffers and
     * read back with Buffers. Due to this structure, it's not uncommon
     * for the Node metadata to be stored in the Buffer along with its secondary
     * keys.
     *
     * Using Buffers also affords the use of virtual copies (externalAppend's),
     * which are used copiously to update the node. For example, when an
     * insert occurs, instead of shifting data, the node performs the following
     * operations (a) virtual copy the first half of the original keys,
     * (b) make a hard copy of the new inserted key, and (c) virtual copy the
     * second half of the original keys.
     *
     * So a simple node structure after an insert may look like this:
     * ------------------------------------------------------------------------
     * | Node A (meta) | keya, keyb | virtual keya, hard keyb, virtual keyc |..
     * ------------------------------------------------------------------------
     *
     * A simple erase (on c) may look something like this
     * ------------------------------------------------------------------------
     * | Node A (meta) | keya, keyb, keyc) | virtual keya, virtual keyb | .....
     * ------------------------------------------------------------------------
     *
     * The important thing to note is that the Node will ALWAYS append a copy
     * (either virtual if it's part of the old keys or hard if it's passed in
     * during an insert) of the keys to the end of the Buffer. This provides
     * two useful properties. The first is that the contents of any pointer
     * (such as a secondary key pointer) returned by the node during its
     * lifetime will remain valid during its lifetime, even if the
     * entry has been 'erased'. Here lifetime means from the time that the
     * local copy is created/read from RAMCloud to the time that the local
     * copy is garbage collected. The second useful property is this allows
     * multiple nodes to be use the same buffer, saving on stack space. So it
     * is also not uncommon to see a buffer layout such as
     *
     * ------------------------------------------------------------------------
     * | Node A(meta)| keysA v1 | Node B(meta)| keysB v1 | keysA v2 | Node C...
     * ------------------------------------------------------------------------
     *
     * The always-appending-a-copy-of-keys-to-the-end property ensures pointer
     * safety within the B+ tree code and allows multiple nodes to share one
     * keyBuffer without using additional space.
     *
     * To support additional structures in subclasses, the base Node class
     * makes the serializeAppendToBuffer() and reinitFromRead() both virtual
     * to support subclasses that need read/write additional data in a buffer
     * for an objectManager read/write. Additionally serializedLength() is
     * also virtual.
     */
    struct Node {
        // Stores the metadata associated with every Secondary Key to
        // Primary Key Hash mapping stored within the node.
        struct KeyInfo {
            // offset of the key blob within the Node's key Buffer relative
            // to the beginning of key array in the Buffer
            int32_t relOffset;

            // Length of the key blob
            uint16_t keyLength;

            // Primary Key Hash associated with the Secondary Key
            uint64_t pkHash;

            // Offset within the Node's key Buffer where the the key blob ends
            // relative to the beginning of the key array in the Buffer
            uint32_t endRelOffset() {
              return relOffset + keyLength;
            }

            // Default constructor
            KeyInfo() : relOffset(0), keyLength(0), pkHash(0) {};
        };

        // Buffer that stores the variable sized entries/keys. Typically, the
        // node itself will reside in the Buffer as well.
        Buffer *keyBuffer;

        // Depending on use case, it is possible that the this node itself is not
        // contained within the key Buffer. For this reason, we need to save
        // where the keys array begins within the buffer.
        uint32_t keysBeginOffset;

        /// Level of the node in the B+ tree. A positive value represents a
        /// inner node and zero represents a leaf.
        uint16_t level;

        /// Number of valid entries stored within the node. A value of n means
        /// that entries [0, n) are valid in the node.
        uint16_t  slotuse;

        /// The amount of space in the keyBuffer dedicated to secondary keys
        /// only.
        uint32_t keyStorageUsed;

        /// Secondary key to primary key hash mappings stored within the node
        KeyInfo keys[IndexBtree::innerslotmax];

        DISALLOW_COPY_AND_ASSIGN(Node);

        /**
         * Constructs a new node specifying a Buffer to use as Key Storage
         * and an optional tree level for the Node ( 0 is leaf level).
         * Modify operations will cause appends to the back of the buffer,
         * so it is not safe to directly modify the contents of the buffer.
         * Always use the node API.
         *
         * \param backingStorage
         *      Buffer to store keys in
         *
         * \param level
         *      level of the node within the Btree
         */
        Node(Buffer *backingStorage, uint16_t level = 0)
          : keyBuffer(backingStorage)
          , keysBeginOffset(backingStorage->size())
          , level(level)
          , slotuse(0)
          , keyStorageUsed(0)
        {}

        virtual ~Node() {}

        /**
         * Returns an entry stored within a Node object at a given index.
         *
         * The entry returned will remain valid as long as the node is not
         * destructed. An optional Buffer can be passed in to retain
         * the contents of the entry beyond destruction.
         *
         * \param index
         *      Index within range [0, slotuse) to access in the node
         *
         * \param[out] keyOutBuffer
         *      Optional Buffer to store the contents of the entry beyond
         *      node destruction/modification.
         *
         * \return
         *      The BtreeEntry at the index
         */
        inline BtreeEntry
        getAt(uint16_t index, Buffer *keyOutBuffer = NULL) const
        {
          assert(index < Node::slotuse);

          uint32_t start = keysBeginOffset + keys[index].relOffset;
          uint16_t keyLength = keys[index].keyLength;
          void *key = keyBuffer->getRange(start, keyLength);

          // If provided, copy key to buffer
          if (keyOutBuffer != NULL) {
            void *ptr = keyOutBuffer->alloc(keyLength);
            memcpy(ptr, key, keyLength);
            key = ptr;
          }

          return BtreeEntry(key, keyLength, keys[index].pkHash);
        }

        /**
         * Sets an entry at the specified slot of the node to be equal to the
         * entry passed in. This overwrites any existing entry at the slot
         * and a setAt the last index will expand the node. The contents of
         * the entry passed in will be copied internally, so it is safe to
         * modify after invocation.
         *
         * This operation primarily is used by inner nodes to update when its
         * children's last entry changes, but it's safe and valid to use in
         * leaf nodes.
         *
         * \param index
         *      index in range [0, slotuse] to store the entry
         *
         * \param entry
         *      the entry to store
         */
        inline void
        setAt(uint16_t index, BtreeEntry entry)
        {
            assert(index <= Node::slotuse);

            if (index < Node::slotuse) {
                int32_t keyLengthDiff = entry.keyLength - keys[index].keyLength;

                uint32_t firstHalfSize = keys[index].relOffset;
                uint32_t lastHalfSize = keyStorageUsed - keys[index].endRelOffset();

                keyBuffer->appendExternal(keyBuffer, keysBeginOffset, firstHalfSize);
                keyBuffer->appendCopy(entry.key, entry.keyLength);
                keyBuffer->appendExternal(keyBuffer,
                        keysBeginOffset + keys[index].endRelOffset(), lastHalfSize);

                // Adjust metadata
                keyStorageUsed += keyLengthDiff;
                keysBeginOffset = keyBuffer->size() - keyStorageUsed;

                keys[index].keyLength = entry.keyLength;
                keys[index].pkHash = entry.pKHash;
                for (uint16_t i = uint16_t(index + 1); i < slotuse; i++) {
                  keys[i].relOffset += keyLengthDiff;
                }
              } else {
                // Index is at the end, so we just append.
                keys[index].keyLength = entry.keyLength;
                keys[index].pkHash = entry.pKHash;
                keys[index].relOffset = keyStorageUsed;

                // Re-append to make sure entries are logically contiguous and
                // references to removed entries are still valid.
                keyBuffer->appendExternal(keyBuffer, keysBeginOffset, keyStorageUsed);
                keyBuffer->appendCopy(entry.key, entry.keyLength);
                keyStorageUsed += entry.keyLength;
                keysBeginOffset = keyBuffer->size() - keyStorageUsed;
                slotuse++;
            }
        }

        /**
         * Returns the last entry stored within the Node.
         *
         * The entry returned will remain valid as long as the node is not
         * destructed. An optional Buffer can be passed in to
         * retain the contents of the entry beyond modification or destruction.
         *
         * \param[out] keyOutBuffer
         *       Optional Buffer to store the contents of the entry beyond
         *       node destruction/modification.
         *
         * \return
         *      The BtreeEntry at the index.
         */
        inline BtreeEntry
        back(Buffer *keyOutBuffer = NULL) const
        {
            assert(0 < Node::slotuse);
            return getAt(uint16_t(slotuse - 1), keyOutBuffer);
        }

        /**
         * Removes the last n entries in the Node. If n is not specified, then
         * only the last entry will be removed. This call will not invalidate
         * previous BtreeEntry's returned via getAt.
         *
         * \param n
         *      The number of Entries at the end to remove.
         */
        inline void
        pop_back(uint16_t n = 1)
        {
            assert(Node::slotuse >= n);

            // Do a virtual copy instead of just decrementing buffer size so
            // any other node's references to the old data will still be valid
            keyStorageUsed = keys[slotuse - n].relOffset;
            keyBuffer->appendExternal(keyBuffer, keysBeginOffset, keyStorageUsed);
            keysBeginOffset = keyBuffer->size() - keyStorageUsed;
            slotuse = uint16_t(slotuse - n);
        }

        /**
         * Internal function to serialize the data in the base Node class
         * to a preallocated region within a buffer. This abstraction is
         * provided primarily for subclasses that wish to build upon the
         * base serialize. After this operation, this node and the copy within
         * the buffer are independent.
         *
         * \param toBuffer
         *      Buffer with contiguous space preallocated for the Node.
         *
         * \param offset
         *      Starting offset for the preallocated space within the buffer.
         *
         * \return
         *      bytes written to the buffer
         */
        uint32_t
        serializeToPreallocatedBuffer(Buffer *toBuffer, uint32_t offset) const
        {
            uint32_t metadataSize =
                    (isLeaf() ? sizeof32(LeafNode) : sizeof32(InnerNode));
            void *ptr;
#if DEBUG_BUILD
            uint32_t contigSpace = toBuffer->peek(offset, &ptr);
            assert (contigSpace >= metadataSize + keyStorageUsed);
#else
            toBuffer->peek(offset, &ptr);
#endif

            // Copy over metadata
            memmove(ptr, this, metadataSize);

            // Copy over keys
            uint32_t bytesRemaining = keyStorageUsed;
            uint8_t *writePtr = static_cast<uint8_t*>(ptr);
            while (bytesRemaining > 0) {
                void *readPtr;
                uint32_t offset = keyStorageUsed - bytesRemaining;
                uint32_t peekSize = keyBuffer->peek(keysBeginOffset + offset, &readPtr);

                if (peekSize < bytesRemaining) {
                    memcpy(writePtr + metadataSize + offset, readPtr, peekSize);
                    bytesRemaining -= peekSize;
                } else {
                    memcpy(writePtr + metadataSize + offset, readPtr, bytesRemaining);
                    break;
                }
            }

            Node *node = reinterpret_cast<Node*>(writePtr);
            node->keysBeginOffset = offset + metadataSize;
            node->keyBuffer = toBuffer;

            return metadataSize + keyStorageUsed;
        }

        /**
         * Copies the entirety of this node's metadata and the keys managed
         * by this base class to a Buffer and returns a pointer to the copied
         * node. After this operation, the copy and original are independent.
         *
         * \param toBuffer
         *      The buffer to copy to.
         *
         * \return
         *      A pointer to the copied node
         */
        virtual Node*
        serializeAppendToBuffer(Buffer *toBuffer) const
        {
            uint32_t startOffset = toBuffer->size();
            uint32_t metadataSize =
                    (isLeaf() ? sizeof32(LeafNode) : sizeof32(InnerNode));

            void *ptr = toBuffer->alloc(metadataSize + keyStorageUsed);
            Node::serializeToPreallocatedBuffer(toBuffer, startOffset);

            return reinterpret_cast<Node*>(ptr);
        }

        /**
         * Reinitializes the node after a read from ObjectManager. This assumes
         * that the Node was serialized via serializeAppendToBuffer() and is now
         * logically contiguous within a buffer starting at a specified offset.
         *
         * \param serializedNodeBuffer
         *      Buffer that contains the Node to be reinitialized. Note that
         *      (a) the metadata portion of the node should be in contiguous
         *      memory and (b) any modification via the Node API will cause
         *      writes to the buffer.
         *
         * \param offset
         *      Where the Node is logically within the buffer.
         */
        virtual void
        reinitFromRead(Buffer *serializedNodeBuffer, uint32_t offset)
        {
            uint32_t nodeSize =
                    ((level == 0) ? sizeof32(LeafNode) : sizeof32(InnerNode));
            keyBuffer = serializedNodeBuffer;
            keysBeginOffset = offset + nodeSize;
        }

        /**
         * Returns the total byte length of the Node (metadata + keys)
         */
        virtual uint32_t
        serializedLength() const=0;

        /**
         * Returns true if the Node is a leaf Node
         */
        inline bool
        isLeaf() const
        {
            return (level == 0);
        }

        /**
         *  Returns true if the Node is an inner Node
         */
        inline bool
        isinnernode() const
        {
          return !isLeaf();
        }

        /**
         * Returns true if the node is full and actions should be taken
         * before inserting a new item.
         */
        inline bool
        isfull() const
        {
            return (Node::slotuse == innerslotmax);
        }

        /**
         * Returns true if the node half full or less, indicative of a node
         * that is either underflowing or about to underflow.
         */
        inline bool
        isfew() const
        {
            return (Node::slotuse <= mininnerslots);
        }

        /**
         * Returns true if the node is underflowing
         */
        inline bool
        isunderflow() const
        {
            return (Node::slotuse < mininnerslots);
        }

        /**
         * Returns a string representation of the node, useful for debugging.
         */
        virtual std::string
        toString() const
        {
            std::ostringstream oStr;
            oStr << "Printing Node keys\r\n";
            for (uint16_t slot = 0; slot < slotuse; ++slot) {
                BtreeEntry e = getAt(slot);
                oStr << e.toString()  << "\r\n";
            }

            return oStr.str();
        }

        /**
         * Prints to log a string representation of the node. This function
         * is provided for instances where the developer wishes to print the
         * entire B+ tree and a string with all the nodes would overflow the
         * RAMCloud Logger's internal buffer size.
         *
         * \param logLevel
         *      Log Level at which to print the node.
         */
        virtual void
        printToLog(enum LogLevel logLevel)
        {
            RAMCLOUD_LOG(logLevel, "%s", toString().c_str());
        }

        /// The following functions are intended for subclass use only
        /// because they only move BtreeEntry's and do not adjust any
        /// subclass metadata such as children pointers for inner nodes.
        /// If a subclass wishes to expose these functions, they must
        /// override them consciously.
        PROTECTED:

         /**
          * Insert an entry into the node at the specified index. The contents
          * of the entry passed in will be copied internally, so it is safe to
          * modify after invocation.
          *
          * \param index
          *      Index to insert the entry between [0, slotuse]
          *
          * \param entry
          *      entry to insert
          */
        inline void
        insertAtEntryOnly(uint16_t index, BtreeEntry entry)
        {
            assert(index <= Node::slotuse);

            // If the slot existed, shift everything to the right by 1 entry
            if (index < Node::slotuse) {
                uint32_t firstHalfSize = keys[index].relOffset;
                uint32_t lastHalfSize = keyStorageUsed - keys[index].relOffset;

                keyBuffer->appendExternal(keyBuffer, keysBeginOffset, firstHalfSize);
                keyBuffer->appendCopy(entry.key, entry.keyLength);
                keyBuffer->appendExternal(keyBuffer,
                        keysBeginOffset + keys[index].relOffset, lastHalfSize);

                // Move + Adjust metadata
                memmove(&keys[index + 1], &keys[index],
                                sizeof(KeyInfo)*(slotuse - index));

                for (uint32_t i = (index + 1); i <= slotuse; i++)
                  keys[i].relOffset += entry.keyLength;

            } else {
                // Re-append to make sure entries are logically contiguous and
                // references to removed entries remain valid.
                keyBuffer->appendExternal(keyBuffer, keysBeginOffset, keyStorageUsed);
                keyBuffer->appendCopy(entry.key, entry.keyLength);
                keys[index].relOffset = keyStorageUsed;
            }

            slotuse++;
            keyStorageUsed += entry.keyLength;
            keysBeginOffset = keyBuffer->size() - keyStorageUsed;
            keys[index].keyLength = entry.keyLength;
            keys[index].pkHash = entry.pKHash;
        }

        /**
         * Erase an entry in the node at the specified index. BtreeEntry's
         * returned by this node will remain valid until destruction.
         *
         *
         * \param index
         *      Index to remove between [0, slotuse)
         */
        inline void
        eraseAtEntryOnly(uint16_t index)
        {
            assert(index <= Node::slotuse);

            uint32_t keyLength = keys[index].keyLength;
            uint32_t firstHalfSize = keys[index].relOffset;
            uint32_t lastHalfSize = keyStorageUsed - keys[index].endRelOffset();

            keyBuffer->appendExternal(keyBuffer,
                    keysBeginOffset, firstHalfSize);
            keyBuffer->appendExternal(keyBuffer,
                    keysBeginOffset + keys[index].endRelOffset(), lastHalfSize);

            keysBeginOffset = keyBuffer->size() - firstHalfSize - lastHalfSize;

            // Move and Adjust metadata
            memmove(&keys[index], &keys[index + 1],
                    sizeof(KeyInfo)*(slotuse - index));

            slotuse--;
            keyStorageUsed -= keyLength;
            for (uint16_t i = index; i < slotuse; i++)
                keys[i].relOffset -= keyLength;
        }

        /**
         * Moves the last numEntries to the beginning of another node.
         *
         * This function uses virtual copies, so it is NOT safe to destroy the
         * source node (this) until dest is no longer needed. However, it is
         * safe to modify the source node via the node API.
         *
         * \param dest
         *      Node to move entries to
         *
         * \param numEntries
         *      Number of entries to move
         */
        inline void
        moveBackEntriesToFrontOf(Node *dest, uint16_t numEntries)
        {
            assert(numEntries + dest->slotuse <= IndexBtree::innerslotmax);
            assert (numEntries <= slotuse);

            uint16_t splitPoint = uint16_t(slotuse - numEntries);
            uint32_t bytesToMove = keyStorageUsed - keys[splitPoint].relOffset;

            dest->keyBuffer->appendExternal(keyBuffer,
                                    keysBeginOffset + keys[splitPoint].relOffset,
                                    bytesToMove);
            dest->keyBuffer->appendExternal(dest->keyBuffer,
                                             dest->keysBeginOffset,
                                             dest->keyStorageUsed);

            memmove(&dest->keys[numEntries],
                    &dest->keys[0],
                    sizeof(KeyInfo)*dest->slotuse);

            memmove(&dest->keys[0],
                    &keys[splitPoint],
                    sizeof(KeyInfo)*numEntries);

            dest->keyStorageUsed += bytesToMove;
            keyStorageUsed -= bytesToMove;
            dest->keysBeginOffset = dest->keyBuffer->size() - dest->keyStorageUsed;

            dest->slotuse = uint16_t(dest->slotuse + numEntries);
            slotuse = uint16_t(slotuse - numEntries);

            uint32_t offset = 0;
            for (uint16_t i = 0; i < dest->slotuse; i++) {
                dest->keys[i].relOffset = offset;
                offset += dest->keys[i].keyLength;
            }
        }

        /**
         * Moves the first numEntries to the end of another node.
         *
         * This function uses virtual copies, so it is NOT safe to destroy the
         * source node (this) until dest is no longer needed. However, it is
         * safe to modify the source node via the node API.
         *
         * \param dest
         *      Node to move entries to
         *
         * \param numEntries
         *      Number of entries to move
         */
        inline void
        moveFrontEntriesToBackOf(Node *dest, uint16_t numEntries)
        {
            assert(numEntries + dest->slotuse <= IndexBtree::innerslotmax);
            assert(numEntries <= slotuse);

            uint32_t bytesToMove = keys[numEntries - 1].endRelOffset();
            // Re-append to make sure keys are logically contiguous
            dest->keyBuffer->appendExternal(dest->keyBuffer,
                                            dest->keysBeginOffset,
                                            dest->keyStorageUsed);
            dest->keyBuffer->appendExternal(keyBuffer, keysBeginOffset, bytesToMove);

            keyBuffer->appendExternal(keyBuffer,
                                    keysBeginOffset + keys[numEntries].relOffset,
                                    keyStorageUsed - bytesToMove);

            memmove(&dest->keys[dest->slotuse], &keys[0], sizeof(KeyInfo)*numEntries);
            memmove(&keys[0], &keys[numEntries], sizeof(KeyInfo)*(slotuse - numEntries));

            uint32_t offset = dest->keyStorageUsed;
            for (uint16_t i = dest->slotuse; i < dest->slotuse + numEntries; i++) {
                dest->keys[i].relOffset = offset;
                offset += dest->keys[i].keyLength;
            }

            dest->keyStorageUsed += bytesToMove;
            keyStorageUsed -= bytesToMove;

            dest->keysBeginOffset = dest->keyBuffer->size() - dest->keyStorageUsed;
            keysBeginOffset = keyBuffer->size() - keyStorageUsed;

            dest->slotuse = uint16_t(dest->slotuse + numEntries);
            slotuse = uint16_t(slotuse - numEntries);

            offset = 0;
            for (uint16_t i = 0; i < slotuse; i++) {
                keys[i].relOffset = offset;
                offset += keys[i].keyLength;
            }
        }
    };

    /**
     * Extended structure of an inner node for the Btree that additionally
     * manages child Node pointers/NodeIds associated with each BtreeEntry.
     * The InnerNode is structured such that there can be up to innerslotmax + 1
     * BtreeEntry's and child NodeId pointers and the relationship between the
     * two is that a BtreeEntry at index i corresponds to the maximum possible
     * BtreeEntry that can be encountered if one were to traverse the subtree
     * pointed to by the child NodeId at index i.
     *
     * One complication that arises with InnerNode is that it needs to keep
     * track of one additional key separate from the Node base class, the
     * rightMostLeafKey. This key is managed independently from the base
     * class's keys and is appended to the end of the buffer when set or
     * serialized to the buffer. Otherwise, it stays in the same place
     * relative to the beginning of the buffer, even in light of modifications
     * to Node base class.
     *
     *
     */
    struct InnerNode : public Node {
        /// Stores the children of the inner_node. There should always be
        /// one more child than Btree Entry's.
        NodeId child[IndexBtree::innerslotmax + 1];

        // Keep track of the right most leaf key reachable by this node. Note
        // the relOffset here is relative to the beginning of the buffer,
        // not to the keysBeginOffset
        KeyInfo rightMostLeafKey;

        // True if this node is along the path to the rightmost/largest key
        // in the Btree.
        bool rightMostLeafKeyIsInfinite;

         /**
         * Constructs a new inner node specifying a Buffer to use as Key
         * Storage and a tree level for the Node.
         * Modify operations will cause appends to the back of the buffer,
         * so it is not safe to directly modify the contents of the buffer.
         * Always use the node API.
         *
         * \param keyBuffer
         *      Buffer used to store variable length keys
         *
         * \param level
         *      level of the node within the Btree
         */
        InnerNode(Buffer *keyBuffer, uint16_t level)
            : Node(keyBuffer, level)
            , child()
            , rightMostLeafKey()
            , rightMostLeafKeyIsInfinite(true)
        { }


        /**
         * Sets the right most leaf key to a particular BtreeEntry.
         *
         * \param entry
         *      BtreeEntry to set right most leaf key to
         */
        void
        setRightMostLeafKey(BtreeEntry entry) {
            // manage the rightmost key separately from the rest of the
            // base class keys
            keyBuffer->appendCopy(entry.key, entry.keyLength);

            // Here, relOffset is relative to beginning of buffer.
            rightMostLeafKey.relOffset = keyBuffer->size() - entry.keyLength;
            rightMostLeafKey.keyLength = entry.keyLength;
            rightMostLeafKey.pkHash = entry.pKHash;

            rightMostLeafKeyIsInfinite = false;
        }

        /**
         * Retrieves the right most leaf key; This entry is invalid if the
         * rightMostLeafKeyIsInfinite bool is set.
         *
         * \return
         *      BtreeEntry signifying the rightmost leaf key.
         */
        BtreeEntry
        getRightMostLeafKey() const {
            void *key = keyBuffer->getRange(rightMostLeafKey.relOffset,
                                            rightMostLeafKey.keyLength);

            return {key, rightMostLeafKey.keyLength, rightMostLeafKey.pkHash};
        }

        virtual ~InnerNode() {}

        /**
         * Insert an entry into the node at the specified index. Inserts at
         * indeces other than the end will cause all entries after the index
         * to be relocated. The contents of the entry passed in will be copied
         * internally, so it is safe to modify after invocation.
         *
         * \param index
         *      Index to insert the entry between [0, slotuse] inclusive
         *
         * \param entry
         *      BtreeEntry to store within the node
         *
         * \param childId
         *      The NodeId pointer associated with the entry
         *
         * \param rightChild (optional)
         *      The NodeId pointer to the right of the entry.
         *
         */
        inline void
        insertAt(uint16_t index, BtreeEntry entry, NodeId childId,
                               NodeId rightChild = INVALID_NODEID)
        {
            Node::insertAtEntryOnly(index, entry);
            memmove(&child[index + 1], &child[index],
                    sizeof(NodeId)*(slotuse - index));

            child[index] = childId;
            if (rightChild != INVALID_NODEID) {
                child[index + 1] = rightChild;
            }
        }

        /**
         * Invoked to insert into an inner node that is already full. It
         * has the same semantics as insertAt, but will split half its
         * contents into an empty inner node passed in.
         *
         * \param insertIndex
         *      Index to insert the entry between [0, slotuse] inclusive
         *
         * \param entry
         *      BtreeEntry to store within the node
         *
         * \param[out] emptyRightSibling
         *      Empty inner node to split half the contents into after insert
         *
         * \param childId
         *      The NodeId pointer associated with the entry
         *
         * \param rightChildId
         *      The NodeId pointer to the right of the entry.
         *
         * \return BtreeEntry
         *      The rightmost entry removed from the node during the split
         *      to maintain the invariant of having 1 more child than entries.
         *
         */
        inline BtreeEntry
        insertSplit(uint16_t insertIndex, BtreeEntry entry,
                                InnerNode *emptyRightSibling, NodeId childId,
                                NodeId rightChildId = INVALID_NODEID)
        {
            assert(emptyRightSibling->slotuse == 0);
            assert(isfull());

            uint16_t half = uint16_t(slotuse >> 1);
            // When an inner_node splits, the left split has to erase
            // one of its entries to maintain the invariant of having
            // 1 more pointer than entries. Thus, we must anticipate
            // where the insert will occur and split so that we end up with
            // exactly half on each side.
            if (insertIndex <= half) {
                memmove(&emptyRightSibling->child[0],
                        &child[half],
                        sizeof(NodeId)*(half + 1));

                Node::moveBackEntriesToFrontOf(emptyRightSibling, half);
                insertAt(insertIndex, entry, childId, rightChildId);
            } else {
                memmove(&emptyRightSibling->child[0],
                        &child[half + 1],
                        sizeof(NodeId)*(half));

                Node::moveBackEntriesToFrontOf(emptyRightSibling, uint16_t(half - 1));
                emptyRightSibling->insertAt(uint16_t(insertIndex - (half + 1)),
                                                entry, childId, rightChildId);
            }

            // Migrate rightmost leaf key and set a new one for self.
            BtreeEntry back = Node::back();
            if (!rightMostLeafKeyIsInfinite)
                emptyRightSibling->setRightMostLeafKey(getRightMostLeafKey());

            rightMostLeafKeyIsInfinite = false;
            rightMostLeafKey.keyLength = back.keyLength;
            rightMostLeafKey.pkHash = back.pKHash;
            rightMostLeafKey.relOffset =
                    keysBeginOffset + keys[slotuse - 1].relOffset;
            Node::pop_back();
            return back;
        }

        /**
         * Erases an BtreeEntry at the specified index and shifts over child
         * metadata. The contents of BtreeEntry's returned by this node
         * will remain valid until destruction.
         *
         * \param index
         *      Index to remove between [0, slotuse] inclusive
         */
        inline void
        eraseAt(uint16_t index)
        {
            // Special case for inner nodes. Since inner nodes can have
            // n + 1 keys and n + 1 pointers, erasing the last pointer is
            // equivalent to promoting the nth pointer to the last pointer.
            if ( index == slotuse) {
                slotuse--;
                keyStorageUsed -= keys[slotuse].keyLength;
                rightMostLeafKey.keyLength = keys[slotuse].keyLength;
                rightMostLeafKey.pkHash = keys[slotuse].pkHash;
                rightMostLeafKey.relOffset =
                        keysBeginOffset + keys[slotuse].relOffset;

                // Reappend to the back to keep references valid.
                keyBuffer->appendExternal(keyBuffer, keysBeginOffset,
                                    keys[slotuse].relOffset);
                keysBeginOffset = keyBuffer->size() - keyStorageUsed;
            } else {
                Node::eraseAtEntryOnly(index);
                memmove(&child[index], &child[index + 1],
                        sizeof(NodeId)*(slotuse + 1 - index));
            }
        }

        /**
         * Return the child pointer/NodeId at the specified index.
         *
         * \param index
         *      Index of child between [0, slotuse] inclusive
         *
         * \return
         *      NodeId of the child at the index
         */
        inline NodeId
        getChildAt(uint16_t index) const
        {
          if (index > Node::slotuse) {
            DIE("Attempted to get a child at an index larger than slotuse");
          }

          return child[index];
        }

        /**
         * Balances the number of entries between between this inner node
         * and its right sibling by moving entries from the more full node to
         * the less full node.
         *
         * \param right
        *      right inner node sibling to balance with
         *
         * \param inbetween
         *      BtreeEntry to insert between the two nodes to maintain the
         *      one more child than entries invariant during the balance
         *
         * \return
         *      this inner node's last entry removed during the balance process
         *      to maintain the one more child than entries invariant.
         */
        inline BtreeEntry
        balanceWithRight(InnerNode *right, BtreeEntry inbetween)
        {
            uint16_t entriesToMove, childrenToMove;
            uint16_t nLeft = slotuse;
            uint16_t nRight = right->slotuse;
            uint16_t half = uint16_t((nLeft + nRight) >> 1);

            // insert the missing link
            uint16_t extraRightChild;
            if (isfull()) {
                right->Node::insertAtEntryOnly(0, inbetween);
                extraRightChild = 1;
            } else {
                Node::insertAtEntryOnly(slotuse, inbetween);
                extraRightChild = 0;
            }

            // Move children and perform balance
            if (nRight < nLeft) {
                entriesToMove = uint16_t(half - nRight);
                childrenToMove = uint16_t(entriesToMove + extraRightChild);

                memmove(&right->child[childrenToMove], &right->child[0],
                        sizeof(NodeId)*(nRight + 1));
                memmove(&right->child[0], &child[nLeft - childrenToMove + 1],
                        sizeof(NodeId)*(childrenToMove));

                Node::moveBackEntriesToFrontOf(right, entriesToMove);
            } else {
                entriesToMove = uint16_t(half - nLeft);

                memmove(&child[nLeft + 1], &right->child[0],
                        sizeof(NodeId)*(entriesToMove));

                memmove(&right->child[0], &right->child[entriesToMove],
                        sizeof(NodeId)*(nRight - entriesToMove + 1));

                right->moveFrontEntriesToBackOf(this, entriesToMove);
            }

            BtreeEntry back = Node::back();
            rightMostLeafKey.keyLength = back.keyLength;
            rightMostLeafKey.pkHash = back.pKHash;
            rightMostLeafKey.relOffset =
                    keysBeginOffset + keys[slotuse - 1].relOffset;
            Node::pop_back();
            return back;
        }

        /**
         * Moves all entries in this inner node to the front of the right
         * inner node.
         *
         * \param right
        *      right inner node sibling to merge with
         *
         * \param inbetween
         *      BtreeEntry to insert between the two nodes to maintain the
         *      one more child than entries invariant during the merge
         */
        inline void
        mergeIntoRight(InnerNode *right, BtreeEntry inbetween)
        {
            Node::insertAtEntryOnly(slotuse, inbetween);

            memmove(&right->child[slotuse], &right->child[0],
                        sizeof(NodeId)*(right->slotuse + 1));
            memmove(&right->child[0], &child[0],
                        sizeof(NodeId)*slotuse);

            Node::moveBackEntriesToFrontOf(right, slotuse);

            keysBeginOffset = keyBuffer->size();
            keyStorageUsed = 0;
            slotuse = 0;
        }

        /**
         * Copies the entirety of this node (metadata and keys) to a Buffer and
         * returns a pointer to the copied node. After this operation, the
         * copy and original are independent.
         *
         * \param toBuffer
         *      The buffer to copy to
         *
         * \return
         *      A pointer to the copied node
         */
        virtual InnerNode*
        serializeAppendToBuffer(Buffer *toBuffer) const
        {
            // If the rightmost key is infinite, there's no need to copy the
            // additional key.
            if (rightMostLeafKeyIsInfinite)
                return static_cast<InnerNode*>(
                                    Node::serializeAppendToBuffer(toBuffer));

            uint32_t startOffset = toBuffer->size();
            void *ptr = toBuffer->alloc(sizeof(InnerNode) + keyStorageUsed
                                        + rightMostLeafKey.keyLength);
            uint32_t bytesWritten =
                    Node::serializeToPreallocatedBuffer(toBuffer, startOffset);

            // Add in our rightmost key
            void *key = keyBuffer->getRange(rightMostLeafKey.relOffset,
                                                    rightMostLeafKey.keyLength);
            uint8_t *keyDst = static_cast<uint8_t*>(ptr) + bytesWritten;
            memmove(keyDst, key, rightMostLeafKey.keyLength);

            InnerNode *n = reinterpret_cast<InnerNode*>(ptr);
            n->rightMostLeafKey.relOffset = bytesWritten;

            return n;
        }

        /**
         * Reinitializes the node after a read from ObjectManager. This assumes
         * that the Node is serialized via serializeAppendToBuffer() and is now
         * logically contiguous within a buffer.
         *
         * \param serializedNodeBuffer
         *      Buffer that contains the Node to be reinitialized. Note that
         *      (a) the metadata portion of the node should be in contiguous
         *      memory and (b) any modification via the Node API will cause
         *      writes to the buffer.
         *
         * \param offset
         *      Where the Node is logically within the buffer.
         */
        virtual void
        reinitFromRead(Buffer *serializedNodeBuffer, uint32_t offset) {
            Node::reinitFromRead(serializedNodeBuffer, offset);
            rightMostLeafKey.relOffset = keysBeginOffset + keyStorageUsed;
        }

        /**
         * Returns the total byte length of the Node (metadata + keys)
         */
        virtual uint32_t
        serializedLength() const {
            return uint32_t(sizeof(InnerNode)
                                + keyStorageUsed
                                + rightMostLeafKey.keyLength);
        }

        /**
         * Returns a string representation of the node, useful for debugging
         *
         * \return
         *      std::string representing the node.
         */
        virtual std::string
        toString() const {
            std::ostringstream oStr;
            oStr << "Printing inner node\r\n";
            for (uint16_t slot = 0; slot < slotuse; ++slot) {
                BtreeEntry e = getAt(slot);
                oStr << "NodeId: " << child[slot] << " <== "
                        << e.toString() << "\r\n";
            }

            oStr << "NodeId: " << child[slotuse] << " <== ";

            if (rightMostLeafKeyIsInfinite)
                oStr << "infinity\r\n";
            else
                oStr << getRightMostLeafKey().toString() <<"\r\n";

            return oStr.str();
        }

        /**
         * Prints to log a string representation of the node. This function
         * is provided for instances where the developer wishes to print the
         * entire B+ tree and a string with all the nodes would overflow the
         * RAMCloud Logger's internal buffer size.
         *
         * \param logLevel
         *      Log Level at which to print the node.
         */
        virtual void
        printToLog(enum LogLevel logLevel) {
            RAMCLOUD_LOG(logLevel, "%s", toString().c_str());
        }
    };

    /// Extended structure of a leaf node in the Btree. It is nearly
    /// identical to the base class with the exception of having
    /// leaf pointers to form a doubly linked list. Note that the
    /// responsibility of managing the linked list falls under IndexBtree.
    struct LeafNode : public Node
    {
        /// Double linked list pointers
        NodeId prevleaf, nextleaf;

        /**
         * Constructs a new leaf node specifying a Buffer to use as Key Storage.
         * Modify operations will cause appends to the back of the buffer,
         * so it is not safe to directly modify the contents of the buffer.
         * Always use the node API.
         *
         * \param backingStore
         *      Buffer to store keys in
         */
        LeafNode(Buffer *backingStore)
            : Node(backingStore, 0)
            , prevleaf(INVALID_NODEID)
            , nextleaf(INVALID_NODEID)
        {}

        /**
         * Performs a split of the current node by moving the last
         * numEntries to the front of the rightSibling leaf node.
         *
         * \param numEntries
         *      number of entries to move to the rightSibling
         *
         * \param rightSibling
         *      leaf node to the right of this in the Btree
         *
         * \return
         *      Last entry
         */
        inline BtreeEntry
        split(uint16_t numEntries, LeafNode *rightSibling) {
            Node::moveBackEntriesToFrontOf(rightSibling, numEntries);
            return Node::back();
        }

        /**
          * Insert an entry into the node at the specified index.
          *
          * \param index
          *      Index to insert the entry between [0, slotuse]
          *
          * \param entry
          *      entry to insert
          */
        inline void
        insertAt(uint16_t index, BtreeEntry entry) {
            Node::insertAtEntryOnly(index, entry);
        }

        /**
         * Erase an entry in the node at the specified index.
         *
         * \param index
         *      Index to remove between [0, slotuse)
         */
        inline void
        eraseAt(uint16_t index) {
            Node::eraseAtEntryOnly(index);
        }

        /**
         * Balances the number of entries between between this leaf node
         * and its leaf sibling by moving entries from the more full node to
         * the less full node.
         *
         * \param right
         *      right leaf node sibling to balance with
         *
         * \return
         *      this leaf node's last entry
         */
        inline BtreeEntry
        balanceWithRight(LeafNode *right) {
            uint16_t toMove, half = uint16_t((slotuse + right->slotuse) >> 1);
            if (right->slotuse < slotuse) {
                toMove = uint16_t(half - right->slotuse);
                Node::moveBackEntriesToFrontOf(right, toMove);
            } else {
                toMove = uint16_t(half - slotuse);
                right->moveFrontEntriesToBackOf(this, toMove);
            }

            return back();
        }

        /**
         * Moves all entries in this leaf node to the front of the right
         * leaf node.
         *
         * \param right
        *      right leaf node sibling to merge with
         */
        inline void
        mergeIntoRight(LeafNode *right) {
            Node::moveBackEntriesToFrontOf(right, slotuse);
            keysBeginOffset = keyBuffer->size();
            keyStorageUsed = 0;
            slotuse = 0;
        }

        /**
         * Returns the total byte length of the Node (metadata + keys)
         */
        virtual uint32_t
        serializedLength() const {
            return uint32_t(sizeof(LeafNode) + keyStorageUsed);
        }

        /**
         * Returns a string representation of the node, useful for debugging
         *
         * \return
         *      std::string representing the node.
         */
        virtual std::string
        toString() const {
            std::ostringstream oStr;
            oStr << "Printing leaf node\r\n";
            oStr << prevleaf << " <- prev | next -> " << nextleaf << "\r\n";
            for (uint16_t slot = 0; slot < slotuse; ++slot) {
                BtreeEntry e = getAt(slot);
                oStr << e.toString().c_str() << "\r\n";
            }

            return oStr.str();
        }

        /**
         * Prints to log a string representation of the node. This function
         * is provided for instances where the developer wishes to print the
         * entire B+ tree and a string with all the nodes would overflow the
         * RAMCloud Logger's internal buffer size.
         *
         * \param logLevel
         *      Log Level at which to print the node.
         */
        virtual void
        printToLog(enum LogLevel logLevel) {
            RAMCLOUD_LOG(logLevel, "%s", toString().c_str());
        }
    };


PUBLIC:
    // *** Constructors and Destructor
    /**
     * Default constructor initializing an empty B+ tree.
     *
     * \param tableId
     *      tableId of the RAMCloud table that this logical tree should use
     *      as a backing table to store its nodes.
     *
     * \param objMgr
     *      Pointer to the objectManager instance that corresponds to a specific
     *      MasterService
     */
    explicit inline IndexBtree(uint64_t tableId, ObjectManager *objMgr)
        : m_stats(), treeTableId(tableId), objMgr(objMgr), nextNodeId(ROOT_ID),
          m_rootId(ROOT_ID), logBuffer(), numEntries(0), cache()
    { }

    /**
     * Constructor initializing a recovered B+ tree.
     *
     * \param tableId
     *      tableId of the RAMCloud table that this logical tree should use
     *      as a backing table to store its nodes.
     *
     * \param objMgr
     *      Pointer to the objectManager instance that corresponds to a specific
     *      MasterService
     *
     * \param nextNodeId
     *      The nextNodeId that the B+ tree should use to create a new node.
     *      This value should be saved from the old tree. An incorrect value
     *      will result in live B+ tree nodes being overwritten!
     */
    explicit inline IndexBtree(uint64_t tableId, ObjectManager *objMgr,
                          uint64_t nextNodeId)
    : m_stats(), treeTableId(tableId), objMgr(objMgr),
        nextNodeId(nextNodeId), m_rootId(ROOT_ID),  logBuffer(),
        numEntries(0), cache()
    { }

    inline ~IndexBtree() { }

  PUBLIC:

    /// Returns the NodeId that will be assigned to the next new node written.
    /// The value will be equal to ROOT_ID when the tree is empty.
    NodeId
    getNextNodeId() {
        return nextNodeId;
    }

    /// Sets the NodeId that will be assigned to the next new node written.
    /// This should be set carefully, as setting it to a value too low would
    /// result in live nodes being overwritten.
    void
    setNextNodeId(NodeId newNodeId) {
        nextNodeId = newNodeId;
    }

    /**
     * Given the value for the RAMCloud object encapsulating an indexlet
     * tree node, check if the node contains (or points to nodes containing)
     * any entries whose key is greater than or equal to compareKey.
     *
     * \param nodeObjectValue
     *      Buffer holding the value of the RAMCloud object encapsulating
     *      this node. The caller must ensure the lifetime of this buffer.
     * \param compareEntry
     *      BtreeEntry to compare against.
     *
     * \return
     *      true if the node (leaf or inner) contains any BtreeEntry's or
     *      paths to BtreeEntry's that are greater than or equal to the
     *      compareKey; false otherwise.
     */
    static bool
    isGreaterOrEqual(Buffer* nodeObjectValue, BtreeEntry compareEntry) {

        Node *n = readNodeFromObjectValue(nodeObjectValue);

        if (n->isLeaf()) {
            RAMCLOUD_LOG(DEBUG, "Checking leaf node entry %s.",
                    (n->back()).toString().c_str());
            return key_greaterequal_static(n->back(), compareEntry);
        }

        InnerNode *inner = static_cast<InnerNode*>(n);
        if (inner->rightMostLeafKeyIsInfinite)
            return true;

        RAMCLOUD_LOG(DEBUG, "Checking inner node entry %s.",
                (inner->getRightMostLeafKey()).toString().c_str());
        return key_greaterequal_static(
                inner->getRightMostLeafKey(), compareEntry);
    }

    PUBLIC:
    /**
     * Fast Destruction of the B+ Tree
     *
     * Lazily frees all nodes in the B+ Tree by detatching the root node
     * and resetting all the metadata. This makes the old nodes unreachable,
     * but the data will still be live in the object manager. With enough
     * future writes into the btree, eventually all the old nodes will be
     * overwritten.
     */
    void
    clear_fast() {
        if (nextNodeId > ROOT_ID) {
            nextNodeId = ROOT_ID;
            m_stats = tree_stats();
            cache.clear();
        }
    }

    /**
     * Destroys the B+ tree by recursively freeing all the nodes *expensive*
     */
    void
    clear() {
        if (nextNodeId > ROOT_ID) {
            clear_recursive(ROOT_ID);
            m_stats = tree_stats();
        }

        flush();
    }

    class iterator; // Forward Declaration

    /**
     * Constructs a read iterator that points to the smallest key in the
     * B+ tree. Incrementing the iterator will result in an ascending
     * traversal of all B+ entries.
     *
     * The iterator is invalidated upon modification to the B+ tree
     * and the BtreeEntry returned on dereference is invalidated upon
     * advancing the iterator.
     *
     * \return
     *      Iterator starting at the first entry in the B+ tree.
     */
    iterator
    begin()
    {
        if (nextNodeId <= ROOT_ID)
            return iterator(this, INVALID_NODEID, 0);

        Buffer nodeBuffer;
        NodeId currentId = m_rootId;
        Node *n = readNode(currentId, &nodeBuffer);

        while (!n->isLeaf()) {
            const InnerNode *inner = static_cast<const InnerNode*>(n);

            currentId = inner->getChildAt(0);
            nodeBuffer.reset();
            n = readNode(currentId, &nodeBuffer);
        }

        return iterator(this, currentId, 0);
    }

    /// Constructs a read iterator that points to the first invalid
    /// slot in the last leaf of the B+ tree.
    iterator
    end() {
        return iterator(this, INVALID_NODEID, 0);
    }

    // *** Access Functions to the Item Count

    /**
     * Return the number of BtreeEntry's in the B+ tree. Note this number
     * maybe incorrect after a Indexlet migration/recovery and should only
     * be used in testing environments where no splits occur.
     *
     * \return
     *      Number of BtreeEntry's in the B+ tree
     */
    uint64_t
    size() const {
        if (nextNodeId <= ROOT_ID)
            return 0;
        else
            return m_stats.itemcount;
    }

    /// Returns true if there is at least one key/data pair in the B+ tree
    bool
    empty() const {
        return (nextNodeId == ROOT_ID);
    }

    // *** Access Functions Querying the Tree by Descending to a Leaf

    /**
     * Checks the existence of a key in the B+ tree
     *
     * \param key
     *      BtreeEntry to find
     *
     * \return
     *      true if the entry exists in the B+ tree.
     */
    bool
    exists(const BtreeEntry &key) {
        return find(key) != end();
    }

    /**
     * Finds a key in the B+ tree and returns an iterator to the entry
     * if found. The iterator will be equal to end() if not found.
     *
     * The iterator is invalidated upon modification to the B+ tree
     * and the BtreeEntry returned on dereference is invalidated upon
     * advancing the iterator.
     *
     * \param key
     *      BtreeEntry to find
     *
     * \return
     *      iterator pointing to entry, or end() if not found.
     */
    iterator
    find(const BtreeEntry &key)
    {
        if (nextNodeId <= ROOT_ID)
            return end();

        Buffer lookupBuffer;
        NodeId currId = m_rootId;
        Node *n = readNode(m_rootId, &lookupBuffer);

        while(!n->isLeaf()) {
            const InnerNode *inner = static_cast<const InnerNode*>(n);
            uint16_t slot = findEntryGE(inner, key);

            currId = inner->getChildAt(slot);
            n = readNode(currId, &lookupBuffer);
        }

        assert (currId >= ROOT_ID);
        uint16_t slot = findEntryGE(n, key);
        return (slot < n->slotuse && key_equal(key, n->getAt(slot)))
            ? iterator(this, currId, slot) : end();
    }

    /**
     * Tries to locate a key in the B+ tree and returns the number of
     * identical entries found.
     *
     * \param key
     *      BtreeEntry to find
     *
     * \return
     *      number of entries found.
     */
    uint64_t
    count(const BtreeEntry &key) const
    {
        if (nextNodeId <= ROOT_ID)
            return 0;

        Buffer buffer;
        NodeId childId = m_rootId;
        Node *n = readNode(m_rootId, &buffer);
        while(!n->isLeaf()) {
            const InnerNode *inner = static_cast<const InnerNode*>(n);
            uint16_t slot = findEntryGE(inner, key);
            childId = inner->getChildAt(slot);
            n = readNode(childId, &buffer);
        }

        const LeafNode *leaf = static_cast<const LeafNode*>(n);
        uint16_t slot = findEntryGE(leaf, key);
        uint64_t num = 0;

        NodeId currentLeafId = childId;
        while (currentLeafId != INVALID_NODEID &&
               slot < leaf->slotuse && key_equal(key, leaf->getAt(slot))) {
            ++num;
            if (++slot >= leaf->slotuse) {
                slot = 0;
                currentLeafId = leaf->nextleaf;
                if (currentLeafId == INVALID_NODEID)
                    break;

                leaf = static_cast<LeafNode*>(readNode(currentLeafId, &buffer));
            }
        }

        return num;
    }

    /**
     * Searches the B+ tree and returns an iterator to the first entry
     * equal to or greater than key, or end() if all keys are smaller.
     *
     * The iterator is invalidated upon modification to the B+ tree
     * and the BtreeEntry returned on dereference is invalidated upon
     * advancing the iterator.
     *
     * \param key
     *      BtreeEntry to start the search
     *
     * \return
     *      B+ tree iterator to the first entry >= key
     */
    iterator
    lower_bound(const BtreeEntry key)
    {
        if (nextNodeId <= ROOT_ID)
            return end();

        Buffer buffer;
        Node *n = readNode(m_rootId, &buffer);
        NodeId childId = m_rootId;
        while(!n->isLeaf()) {
            const InnerNode *inner = static_cast<const InnerNode*>(n);
            uint16_t slot = findEntryGE(inner, key);
            childId = inner->getChildAt(slot);
            n = readNode(childId, &buffer);
        }

        const LeafNode *leaf = static_cast<const LeafNode*>(n);
        uint16_t slot = findEntryGE(leaf, key);

        // If the slot returned by find_upper() is beyond the last element
        // in use, return end()
        if (slot >= leaf->slotuse)
            return end();
        else
            return iterator(this, childId, slot);
    }

    /**
     * Searches the B+ tree and returns an iterator to the first entry
     * that is greater than the key, or end() if all keys are smaller
     * or equal.
     *
     * The iterator is invalidated upon modification to the B+ tree
     * and the BtreeEntry returned on dereference is invalidated upon
     * advancing the iterator.
     *
     * \param key
     *      BtreeEntry to start the search
     *
     * \return
     *      B+ tree iterator to the first entry > key
     */
    iterator
    upper_bound(const BtreeEntry& key)
    {
        if (nextNodeId <= ROOT_ID)
            return end();

        Buffer nodeBuffer;
        Node *n = readNode(m_rootId, &nodeBuffer);
        NodeId childId = m_rootId;
        while(!n->isLeaf()) {
            InnerNode *inner = static_cast<InnerNode*>(n);
            uint16_t slot = findEntryGreater(inner, key);
            childId = inner->getChildAt(slot);
            n = readNode(childId, &nodeBuffer);
        }

        const LeafNode *leaf = static_cast<const LeafNode*>(n);
        uint16_t slot = findEntryGreater(leaf, key);

        // If the slot returned by find_upper() is beyond the last element
        // in use, return end()
        if (slot >= leaf->slotuse)
            return end();
        else
            return iterator(this, childId, slot);
    }

    // *** Modify Functions Changing the Tree by Descending to a Leaf
    /**
     * Starts an insert operation from the root.
     *
     * \param entry
     *      Entry to insert into the B+tree
     */
    void
    insert(const BtreeEntry entry) {
        if (nextNodeId == ROOT_ID) {
            Buffer rootBuffer;
            LeafNode *root = rootBuffer.emplaceAppend<LeafNode>(&rootBuffer);
            root->insertAt(0, entry);
            writeNode(root, ROOT_ID);
            nextNodeId = ROOT_ID + 1;
            m_stats.leaves = 1;
        } else {
            ChildUpdateInfo info;
            insertDescend(ROOT_ID, entry, &info);

            // Root node was split
            if (info.childSplit) {
                Buffer rootBuffer;
                uint16_t rootLevel = uint16_t(info.getChildLevel() + 1);
                InnerNode *newRoot =
                        rootBuffer.emplaceAppend<InnerNode>(&rootBuffer, rootLevel);
                newRoot->insertAt(0,
                        info.newChild,
                        info.newChildId,
                        info.rightSiblingId);
                writeNode(newRoot, ROOT_ID);
                m_stats.innernodes++;
            }
        }

        flush();
        m_stats.itemcount++;
    }

    /**
     * Erases one Entry in the B+ tree
     *
     * \param entry
     *      Entry to erase
     *
     * \return
     *      true if the entry was found and erased.
     */
    bool
    erase(BtreeEntry entry) {
        if (selfverify) verify();

        // The tree is empty; do nothing.
        if (nextNodeId <= ROOT_ID)
            return false;

        EraseUpdateInfo info;
        bool success = eraseOneDescend(entry, m_rootId, NULL, 0, &info);

        flush();
        if (selfverify) verify();
        return success;
    }

PRIVATE:
    // *** Search functions to be used internally on nodes

    /// Returns true if a < b first according to IndexKey and then by pKHash
    inline bool
    key_less(const BtreeEntry a, const BtreeEntry b) const
    {
        int keyComparison = IndexKey::keyCompare(a.key, a.keyLength,
                                                 b.key, b.keyLength);
        return (keyComparison == 0) ? (a.pKHash < b.pKHash) : keyComparison < 0;
    }

    /// Static version of key_less().
    static bool
    key_less_static(const BtreeEntry a, const BtreeEntry b)
    {
        int keyComparison = IndexKey::keyCompare(a.key, a.keyLength,
                                                 b.key, b.keyLength);
        return (keyComparison == 0) ? (a.pKHash < b.pKHash) : keyComparison < 0;
    }

    // *** Convenient Key Comparison Functions Generated From key_less

    /// True if a <= b ? constructed from key_less()
    inline bool
    key_lessequal(const BtreeEntry a, const BtreeEntry b) const
    {
        return !key_less(b, a);
    }

    /// True if a > b ? constructed from key_less()
    inline bool
    key_greater(const BtreeEntry a, const BtreeEntry &b) const
    {
        return key_less(b, a);
    }

    /// True if a >= b ? constructed from key_less()
    inline bool
    key_greaterequal(const BtreeEntry a, const BtreeEntry b) const
    {
        return !key_less(a, b);
    }

    // Static version of key_greaterequal().
    static bool
    key_greaterequal_static(const BtreeEntry a, const BtreeEntry b)
    {
        return !key_less_static(a, b);
    }

    /// True if a == b ? constructed from key_less(). This requires the <
    /// relation to be a total order, otherwise the B+ tree cannot be sorted.
    inline bool
    key_equal(const BtreeEntry a, const BtreeEntry b) const {
      return IndexKey::keyCompare(a.key, a.keyLength, b.key, b.keyLength) == 0
              && a.pKHash == b.pKHash;
    }

    /**
     * Searches for the first entry in Node n that is greater than or equal to
     * the entry passed in and returns the index. An index value greater
     * than the number of entries in the node indicates that all the entries
     * in the node are less than the entry passed in.
     *
     * \param n
     *      Node to search within
     *
     * \param entry
     *      BtreeEntry to compare against
     *
     * \return
     *      Index within the Node
     */
    inline uint16_t
    findEntryGE(const Node *n, BtreeEntry entry) const
    {
        if ( useBinarySearch ) {
            if (n->slotuse == 0)
                return 0;

            uint16_t lo = 0, hi = n->slotuse;
            while (lo < hi) {
                uint16_t mid = uint16_t((lo + hi) >> 1);
                if (key_lessequal(entry, n->getAt(mid))) {
                    hi = mid; // key <= mid
                } else {
                    lo = uint16_t(mid + 1); // key > mid
                }
            }

            // verify result using simple linear search
            if (selfverify) {
                uint16_t i = 0;
                while (i < n->slotuse && key_less(n->getAt(i), entry)) ++i;
                assert(i == lo);
            }

            return lo;
        } else {
            uint16_t lo = 0;
            while (lo < n->slotuse && key_less(n->getAt(lo), entry)) ++lo;
            return lo;
        }
    }

    /**
     * Searches for the first entry in Node n that is greater than the entry
     * passed in and returns its index. An index value greater than the number
     * of entries in the node indicates that all the entries in the node are
     * less than or equal to the entry passed in.
     *
     * \param n
     *      Node to search within
     *
     * \param entry
     *      BtreeEntry to compare against
     *
     * \return
     *      Index within the Node
     */
    inline uint16_t
    findEntryGreater(const Node *n, const BtreeEntry entry) const
    {
        if ( useBinarySearch ) {
            if (n->slotuse == 0)
                return 0;

            uint16_t lo = 0, hi = n->slotuse;
            while (lo < hi) {
                uint16_t mid = uint16_t((lo + hi) >> 1);
                if (key_less(entry, n->getAt(mid))) {
                    hi = mid; // key < mid
                } else {
                    lo = uint16_t(mid + 1); // key >= mid
                }
            }

            // verify result using simple linear search
            if (selfverify)
            {
                uint16_t i = 0;
                while (i < n->slotuse && key_lessequal(n->getAt(i), entry)) ++i;
                assert(i == hi);
            }

            return lo;
        } else  {
            uint16_t lo = 0;
            while (lo < n->slotuse && key_lessequal(n->getAt(lo), entry)) ++lo;
            return lo;
        }
    }

    // *** Helper functions to allow using RamCloud objects for B+ tree nodes

    /**
     * Removes a particular node by nodeId in the Btree's backing table.
     * This will not remove any children (in the case of a inner node) or fix
     * any pointers. It is the responsibility of the caller to ensure that it is
     * safe to remove the node before invoking this. Also note, this function
     * only prepares a tombstone to be written in the log and requires an
     * invocation of ObjectManager's flushEnteriesToLog to persist the changes.
     *
     * \param nodeId
     *      The id of the node to be deleted from the backing table.
     *
     */
    inline void
    freeNode(NodeId nodeId)
    {
        Key key(treeTableId, &nodeId, sizeof(NodeId));
#if DEBUG_BUILD
        Status status = objMgr->writeTombstone(key, &logBuffer);
        assert(status == STATUS_OK);
#else
        objMgr->writeTombstone(key, &logBuffer);
#endif
        numEntries++;
        if (nodeId == m_rootId)
            nextNodeId = ROOT_ID;
    }

    /**
     * Read the node (RAMCloud object) corresponding to a given nodeId
     * and return a pointer to a contiguous copy of the node in memory.
     *
     * \param nodeId
     *      The primary key for the RAMCloud object corresponding
     *      to the B+ tree node to be read.
     *
     * \param[out] outBuffer
     *      Buffer to hold the contents of the object. The caller must ensure
     *      that this is NOT NULL.
     *
     * \return
     *      A pointer the Node read.
     */
    inline Node*
    readNode(NodeId nodeId, Buffer* outBuffer) const {
        // Read from objMaster
        uint32_t sizeBeforeRead = outBuffer->size();
        Key key(treeTableId, &nodeId, sizeof(NodeId));
        Status status = objMgr->readObject(key, outBuffer, NULL, NULL, true);
        if (status != STATUS_OK) {
            RAMCLOUD_LOG(DEBUG, "Cant read NodeId %lu", nodeId);
            return NULL;
        }

        // The trickiness here is that an inner node has more metadata
        // than the other nodes types. Hence, we first read it back as a Node
        // object, which is contains enough metadata to determine its real type.
        // Then read it out in full.
        Node *ptr;
        uint32_t peekSize = outBuffer->peek(sizeBeforeRead, ((void**)&ptr));
        if (peekSize < sizeof(Node)) {
            ptr = static_cast<Node*>(outBuffer->getRange(sizeBeforeRead,
                    sizeof(Node)));
        }

        uint32_t nodeSize =
                (ptr->isLeaf() ? sizeof32(LeafNode) : sizeof32(InnerNode));

        if (peekSize < nodeSize) {
            ptr = static_cast<Node*>(outBuffer->alloc(nodeSize));
            memmove(ptr, outBuffer->getRange(sizeBeforeRead, nodeSize), nodeSize);
        }

        RAMCLOUD_LOG(DEBUG, "Read object from log, nodeId = %lu, size = %d",
                     nodeId, ptr->serializedLength());

        ptr->reinitFromRead(outBuffer, sizeBeforeRead);
        PerfStats::threadStats.btreeNodeReads++;
        PerfStats::threadStats.btreeBytesRead += (ptr->serializedLength());
        return ptr;
    }

    /**
     * Given a buffer encapsulating the node (i.e., value of the RAMCloud
     * object corresponding to this node), return a pointer to a contiguous
     * copy of the node in memory.
     *
     * \param nodeObjectValue
     *      Buffer holding the value of the RAMCloud object encapsulating
     *      this node. The caller must ensure the lifetime of this buffer.
     *
     * \return
     *      A pointer the Node read.
     */
    static Node*
    readNodeFromObjectValue(Buffer* nodeObjectValue) {
        // The trickiness here is that an inner node has more metadata
        // than the other nodes types. Hence, we first read it back as a Node
        // object, which is contains enough metadata to determine its real type.
        // Then read it out in full.
        Node *ptr;
        uint32_t peekSize = nodeObjectValue->peek(0, ((void**)&ptr));
        if (peekSize < sizeof(Node)) {
            ptr = static_cast<Node*>(
                    nodeObjectValue->getRange(0, sizeof(Node)));
        }

        uint32_t nodeSize =
                (ptr->isLeaf() ? sizeof32(LeafNode) : sizeof32(InnerNode));

        if (peekSize < nodeSize) {
            ptr = static_cast<Node*>(nodeObjectValue->alloc(nodeSize));
            memmove(ptr, nodeObjectValue->getRange(0, nodeSize),
                    nodeSize);
        }

        ptr->reinitFromRead(nodeObjectValue, 0);
        return ptr;
    }

    /**
     * Write a B+ tree node as a RamCloud object. After the call returns,
     * it is safe to modify or destroy the tree node passed in.
     *
     * \param node
     *      This points to the tree node to be written
     *
     * \param nodeId (optional)
     *      The nodeId (primary key) for the new object that will be
     *      written out in this function. If not provided, the primary key
     *      for this object will be chosen as nextNodeId which is global to
     *      the tree.
     *
     * \return
     *      The nodeId (primary key) used for this object.
     */
    inline NodeId
    writeNode(const Node *node, NodeId nodeId = INVALID_NODEID) {
      if (nodeId == INVALID_NODEID)
        nodeId = nextNodeId++;

      Buffer buffer;
      Key key(treeTableId, &nodeId, sizeof(NodeId));
      RAMCLOUD_LOG(DEBUG, "Writing key(nodeId) is %lu, size of node = %d",
                     nodeId, node->serializedLength());

      Node *serializedNode = node->serializeAppendToBuffer(&buffer);
      serializedNode->keyBuffer = NULL; // Helps catch errors in case a person reads a node back incorrectly.
      Object object(key, serializedNode, node->serializedLength(), 1, 0, buffer);

      // here size is the size of the object's value. ObjectManager
      // will construct an object around this.
      bool tombstoneAdded = false;
      uint32_t nodeOffset = 0;
      Status status = objMgr->prepareForLog(object, &logBuffer,
                                         &nodeOffset, &tombstoneAdded);

      cache[nodeId] = nodeOffset;

      if (tombstoneAdded)
          numEntries+= 2;
      else
          numEntries++;

      PerfStats::threadStats.btreeNodeWrites++;
      PerfStats::threadStats.btreeBytesWritten += node->serializedLength();

      if (status != STATUS_OK) {
        assert(status == STATUS_OK);
      }
      return nodeId;
    }

    /**
     * Performs a depth first traversal of the tree starting at nodeId deleting
     * any nodes it encounters. This should ONLY be used for deleting the entire
     * tree e.g. by clear() because metadata structures (such as next and
     * previous pointers at the leaf level) are NOT updated during the delete.
     *
     * \param nodeId
     *      Node to start deletion at
     */
    void
    clear_recursive(NodeId nodeId) {
        Buffer buffer;
        Node *n = readNode(nodeId, &buffer);

        if (n->isinnernode()) {
            const InnerNode *innernode = static_cast<const InnerNode*>(n);
            for (uint16_t slot = 0; slot <= innernode->slotuse; ++slot)
                clear_recursive(innernode->getChildAt(slot));
        }

        freeNode(nodeId);
    }

    /**
     * Flushes Node writes and tombstones to log atomically.
     */
    inline void
    flush() {
        bool status = objMgr->flushEntriesToLog(&logBuffer, numEntries);
        if (status != true) {
            assert(status == true);
        }
        cache.clear();
    }

PRIVATE:

    /**
     * Stores the result of an insert operation on a subtree, used to determine
     * whether the parent call/node needs to be updated.
     *
     * The only tree modifications that can happen in an insert is that a
     * new child was created due to an overflowing node or the insert happened
     * to be the new rightmost key of a leaf node and thus must be propagated
     * up. This structure stores information about that node.
     */
    struct ChildUpdateInfo {

      /// The new entry that should be used by the parent to index the child.
      BtreeEntry newChild;

      /// NodeId of the new child
      NodeId newChildId;

      /// The right sibling of the new child.
      NodeId rightSiblingId;

      // Stores the level at which the new child resides.
      uint16_t childLevel;

      // Indicates whether a child split occurred and whether the values
      // above are valid or not.
      bool childSplit;

      // Indicates that the rightmost leaf key was updated in a descendant node
      // and should be propagated upward into the parent. This should be cleared
      // when the child is no longer the rightmost.
      bool rightMostKeyUpdated;

      // Stores the rightmost leaf key.
      BtreeEntry rightMostLeafKey;

      /// Used to store the variable sized keys so that the original entry
      /// referenced can be deleted
      Buffer keyBuffer;

      ChildUpdateInfo()
        : newChild()
        , newChildId(INVALID_NODEID)
        , rightSiblingId(INVALID_NODEID)
        , childLevel(0)
        , childSplit(false)
        , rightMostKeyUpdated(false)
        , rightMostLeafKey()
        , keyBuffer()
      {}

      /**
       * Sets this structure to reflect the result of a split operation for
       * a parent InnerNode to consume. Here, 'curr' refers to the left half
       * of a resulting split after an insert and 'right' refers to the right
       * half of said split.
       *
       * \param currLastEntry
       *      rightmost leaf key contained within the left split of the subtree
       *
       * \param currChildId
       *      the NodeId of the left child node
       *
       * \param rightSiblingId
       *      the NodeId of the right child node
       *
       * \param level
       *      The level in the B+ tree where the split occurred. The parent
       *      should always be one more than this parameter.
       */
      void setSplit(BtreeEntry currLastEntry, NodeId currChildId,
                NodeId rightSiblingId, uint16_t level) {
        void *ptr;
        newChild.keyLength = currLastEntry.keyLength;
        newChild.pKHash = currLastEntry.pKHash;
        ptr = keyBuffer.alloc(currLastEntry.keyLength);
        memcpy(ptr, currLastEntry.key, currLastEntry.keyLength);
        newChild.key = ptr;

        newChildId = currChildId;
        this->rightSiblingId = rightSiblingId;
        childLevel = level;
        childSplit = true;
      }


      /**
       * Indicates to the parent node that the insert affected the right most
       * leaf key in the subtree it called the recursive insertDescend on.
       *
       * \param lastKeyIn
       *        The new right most leaf key
       */
      void setLastKeyUpdated(BtreeEntry lastKeyIn) {
            rightMostKeyUpdated = true;

            rightMostLeafKey.keyLength = lastKeyIn.keyLength;
            rightMostLeafKey.pKHash = lastKeyIn.pKHash;
            void *ptr = keyBuffer.alloc(rightMostLeafKey.keyLength);
            memcpy(ptr, lastKeyIn.key, lastKeyIn.keyLength);
            rightMostLeafKey.key = ptr;
      }

      void
      clear() {
        childSplit = false;
      }

      BtreeEntry
      getChild() {
        return newChild;
      }

      NodeId
      getRightSiblingId() {
        return rightSiblingId;
      }

      uint16_t
      getChildLevel() {
        return childLevel;
      }
    };

    // Stores the result of a recursive eraseOneDescend call one level down
    // and is used by the parent call to determine whether updates are required
    // for the current node at the call site. The key intuition here is that
    // if an underflow occurs at the lower levels, then the only two possible
    // outcomes are either two children are balanced or merged. In the former
    // case, we need to track that a child's last index changed (only 1 will
    // change because only 1 child's last key would have changed) and in the
    // latter case, we only need to track which node was deleted in the merge.
    // Additionally, we also track if the last key of the rightmost leaf
    // changed via an erase the change needs to propagate up the tree.
    struct EraseUpdateInfo {
        enum updateOperation {
            setLeft,
            setCurr,
            delLeft,
            delCurr,
            noOp
        };

        /// Indicates whether the last entry (aka rightmost entry) in the
        // subtree has changed during an erase operation.
        bool lastEntryUpdated;

        /// Stores the last entry, if changed
        BtreeEntry lastEntry;

        /// What operation the parent node should apply because of a
        /// merge/balance operation in the subtree.
        enum updateOperation op;

        /// If updateOperation is a set*, this stores the value to be set.
        BtreeEntry setEntry;

        // Physically stores the keys in the updated children whose last entries changed.
        // The buffer is needed since the original child's buffer would have
        // already been garbage collected.
        Buffer keyBuffer;

        EraseUpdateInfo() : lastEntryUpdated(false), lastEntry(),
                            op(noOp), setEntry(), keyBuffer()
        {}

        void setSetEntry(BtreeEntry e) {
            copyKeyInternal(&setEntry, &e);
        }

        void setLastKey(BtreeEntry e) {
            lastEntryUpdated = true;
            copyKeyInternal(&lastEntry, &e);
        }

        /// Copies the entry to internal Buffer storage so that the original
        /// entry's key can be freed without consequence
        void copyKeyInternal(BtreeEntry *to, BtreeEntry *from) {
            *to = *from;

            void *ptr = keyBuffer.alloc(from->keyLength);
            memcpy(ptr, from->key, from->keyLength);
            to->key = ptr;
        }

        /// Clears the operation in prep for resuse. Note that the lastKey
        /// is not cleared since
        void clearOp() {
            op = noOp;
        }
    };

    /**
     * Descends down a subtree to insert an entry into the B+ tree correctly.
     * Any Node overflows are handled along the way by splitting the node
     * and updating the parent.
     *
     * \param currentId
     *      NodeId of the node to start the insert process from
     *
     * \param entry
     *      BtreeEntry to insert
     *
     * \param updateInfo
     *      Tracks changes made during the insert that need to be reflected
     *      in parent node.
     */
    void
    insertDescend(NodeId currentId, BtreeEntry entry,
                       ChildUpdateInfo *updateInfo) {
      Buffer buffer;
      Node *n = readNode(currentId, &buffer);

      /* -Clever Trick-
      * First note that an inner node indexes its left children by
      * storing their rightmost leaf keys a branching point. Now, if the
      * parent call into insertDescend finds the first branching point that is
      * greater than or equal to the entry to be inserted, then new entry
      * will never be inserted at the end of the child. This saves us a
      * parent update if no splits occur.
      *
      * (Note: The never-insert-at-end property doesn't hold for the rightmost
      * key since those need to be propagated up the tree. )
      */
      uint16_t insertIndex = findEntryGE(n, entry);

      if (n->isinnernode()) {
        InnerNode* inner = (InnerNode*) n;

        updateInfo->clear();
        insertDescend(inner->getChildAt(insertIndex), entry, updateInfo);

        // The right most leaf key has been updated on our descent.
        // Integrate it if it's larger than our current entry for that slot
        bool rightMostKeyUpdated = false;
        if (updateInfo->rightMostKeyUpdated &&
                !inner->rightMostLeafKeyIsInfinite) {
            if (insertIndex < inner->slotuse) {
                // The slot is not at the end, time to stop the propagation
                updateInfo->rightMostKeyUpdated = false;

                if (key_less(inner->getAt(insertIndex),
                        updateInfo->rightMostLeafKey)) {
                    rightMostKeyUpdated = true;
                    inner->setAt(insertIndex, updateInfo->rightMostLeafKey);
                }
            } else if (key_less(inner->getRightMostLeafKey(),
                    updateInfo->rightMostLeafKey)){
                rightMostKeyUpdated = true;
                inner->setRightMostLeafKey(updateInfo->rightMostLeafKey);
            }
        }

        // No split, so we're done;
        if (!updateInfo->childSplit) {
            if (rightMostKeyUpdated)
                writeNode(inner, currentId);

            return;
        }

        if (!inner->isfull()) {
          inner->insertAt(insertIndex,
                  updateInfo->newChild,
                  updateInfo->newChildId,
                  updateInfo->rightSiblingId);
          writeNode(inner, currentId);
          updateInfo->clear();
          return;
        }

        // Inner is full, need to split;
        InnerNode *newRightSibling =
                buffer.emplaceAppend<InnerNode>(&buffer, inner->level);
        m_stats.innernodes++;
        BtreeEntry newLastEntry = inner->insertSplit(insertIndex,
                                    updateInfo->getChild(),
                                    newRightSibling,
                                    updateInfo->newChildId,
                                    updateInfo->getRightSiblingId());
        PerfStats::threadStats.btreeNodeSplits++;

        // If the root is split, rewrite the current root using a
        // new NodeId so that the new root can have NodeId = m_rootId
        NodeId rightId = (currentId == m_rootId) ? nextNodeId++ : currentId;
        NodeId leftId = nextNodeId++;

        // In an inner split, the last entry in the lesser split will
        // migrate up to the parent.
        updateInfo->setSplit(newLastEntry, leftId, rightId, inner->level);
        if (!newRightSibling->rightMostLeafKeyIsInfinite)
            updateInfo->setLastKeyUpdated(
                                        newRightSibling->getRightMostLeafKey());

        writeNode(inner, leftId);
        writeNode(newRightSibling, rightId);
      } else {
        LeafNode *leaf = static_cast<LeafNode*>(n);

        if (insertIndex == leaf->slotuse)
            updateInfo->setLastKeyUpdated(entry);

        if (!leaf->isfull()) {
          leaf->insertAt(insertIndex, entry);
          writeNode(leaf, currentId);
          updateInfo->clear();

          return;
        }

        // Leaf is full, split
        uint16_t midpoint = uint16_t(leaf->slotuse >> 1);
        LeafNode *newRightSibling = buffer.emplaceAppend<LeafNode>(&buffer);
        m_stats.leaves++;
        leaf->split(midpoint, newRightSibling);
        PerfStats::threadStats.btreeNodeSplits++;

        if (insertIndex < leaf->slotuse) {
           leaf->insertAt(insertIndex, entry);
         } else {
           newRightSibling->insertAt(uint16_t(insertIndex - midpoint), entry);
         }

        // If the root is split, rewrite the current root using a
        // new NodeId so that the new root can have NodeId = m_rootId
        NodeId rightId = (currentId == m_rootId) ? nextNodeId++ : currentId;
        NodeId leftId = nextNodeId++;

        updateInfo->setSplit(leaf->back(), leftId, rightId, leaf->level);
        updateInfo->setLastKeyUpdated(newRightSibling->back());

        // Adjust the leaf pointers and write
        newRightSibling->nextleaf = leaf->nextleaf;
        newRightSibling->prevleaf = leftId;
        leaf->nextleaf = rightId;

        assert(leftId == m_rootId || !leaf->isunderflow());
        assert(rightId == m_rootId || !newRightSibling->isunderflow());

        writeNode(leaf, leftId);
        writeNode(newRightSibling, rightId);

        // Update the left sibling
        if (leaf->prevleaf != INVALID_NODEID) {
          LeafNode *prevLeaf =
                  static_cast<LeafNode*>(readNode(leaf->prevleaf, &buffer));
          prevLeaf->nextleaf = leftId;
          writeNode(prevLeaf, leaf->prevleaf);
        }
      }
    }

    /**
     * Descends down a sub tree in search of an entry. Once it is found, it is
     * removed from the leaf and any node that underflows along the path are
     * handled by merging and shifting entries.
     *
     * \param key
     *      BtreeEntry to remove from the sub tree
     *
     * \param currentId
     *      NodeId of the node to start search in for the entry
     *
     * \param parent
     *      parent inner node  of the current node to search. NULL if the
     *      current node is the root.
     *
     * \param parentSlot
     *      The current node's index within the parent. Not used if the
     *      current node is the root
     *
     * \param[out] info
     *      Stores information on how to update the parent node if
     *      the subtree has changed.
     *
     * \return
     */
    bool
    eraseOneDescend(BtreeEntry key, NodeId currentId,
                             const InnerNode *parent, uint16_t parentSlot,
                             EraseUpdateInfo *info)
    {
        Buffer currentBuffer;
        Node *node = readNode(currentId, &currentBuffer);
        uint16_t slot = findEntryGE(node, key);
        bool dirty = false;

        if (node->isLeaf())
        {
            // If key is out of range or not found, return without doing anything.
            if (slot >= node->slotuse || !key_equal(key, node->getAt(slot)))
                return false;

            // Key Found
            LeafNode *currLeaf = static_cast<LeafNode*>(node);
            currLeaf->eraseAt(slot);
            m_stats.itemcount--;
            dirty = true;

            if (slot == currLeaf->slotuse && currentId != ROOT_ID)
                info->setLastKey(currLeaf->back());
        }
        else
        {
            InnerNode *inner = static_cast<InnerNode*>(node);
            NodeId childId = inner->getChildAt(slot);

            info->clearOp();
            bool success = eraseOneDescend(key, childId, inner, slot, info);
            if (!success)
                return false;

            // The right most leaf key has been updated on our descent.
            // Integrate it if it's larger than our current entry for that slot
            if (info->lastEntryUpdated && !inner->rightMostLeafKeyIsInfinite) {
                if (slot < node->slotuse) {
                    info->lastEntryUpdated = false;
                    if (key_less(inner->getAt(slot), info->lastEntry)) {
                        inner->setAt(slot, info->lastEntry);
                        dirty = true;
                    }
                } else if (key_less(inner->getRightMostLeafKey(),
                                                            info->lastEntry)) {
                    inner->setRightMostLeafKey(info->lastEntry);
                    dirty = true;
                }
            }

            // Apply the updates from our children; The goal here is to apply
            // local and clear the local changes.
            dirty |= (info->op < EraseUpdateInfo::noOp);
            uint16_t leftSlot = uint16_t(slot - 1);
            switch(info->op) {
                case EraseUpdateInfo::setLeft:
                    inner->setAt(leftSlot, info->setEntry);
                    break;
                case EraseUpdateInfo::setCurr:
                    inner->setAt(slot, info->setEntry);
                    break;
                case EraseUpdateInfo::delLeft:
                    inner->eraseAt(leftSlot);
                    break;
                case EraseUpdateInfo::delCurr:
                    inner->eraseAt(slot);
                    break;
                default:
                    break;
            }

            // clear child info and report our own modifications up to the parent
            info->clearOp();
        }

        if (node->isunderflow() && !(currentId == m_rootId && node->slotuse >= 1)) {
            handleUnderflowAndWrite(node, currentId, parent, parentSlot, info);
        } else if (dirty) {
            writeNode(node, currentId);
        }

        return true;
    }

    /**
     * Restores the minimum node size invariant after an erase operation
     * by merging, balancing, and promoting nodes. Since the offending node
     * may be eliminated in this call, it is NOT safe to used the node passed
     * into curr after this call.
     *
     * \param curr
     *      The node that is violating the invariant
     *
     * \param currId
     *      The nodeId of the offending
     *
     * \param parent
     *      The parent node of the offending node. May be NULL
     *      in the case that the offending node is the root.
     *
     * \param parentSlot
     *      The index location of where the offending node is in its parent.
     *
     * \param[out] info
     *      If the parent node needs to be modified because of this call,
     *      the info needed to do so will be stored here.
     */
    inline void
    handleUnderflowAndWrite(Node *curr, NodeId currId,
                         const InnerNode *parent, uint16_t parentSlot,
                         EraseUpdateInfo *info)
    {
        Buffer buffer;

        // Special case: root, which is allowed to underflow, has depleted
        if (currId == m_rootId && curr->slotuse == 0) {
            if (curr->isLeaf()) {
                freeNode(m_rootId);
                m_stats.leaves--;
                return;
            }

            // Root is not a leaf, so we must promote our last child.
            InnerNode *inner = static_cast<InnerNode*>(curr);

            NodeId childId = inner->getChildAt(0);
            std::map<NodeId, uint32_t>::iterator it = cache.find(childId);
            Node *newRoot;
            if (it == cache.end()) {
                newRoot = readNode(childId, &buffer);
            } else {
                newRoot = static_cast<Node*>(
                                logBuffer.getRange(it->second, sizeof(Node)));

                // Readjust buffer
                newRoot->reinitFromRead(&logBuffer, it->second);
            }

            writeNode(newRoot, m_rootId);
            freeNode(childId);
            m_stats.innernodes--;
            return;
        }

        // Due to the minimum node size invariant, there should always be
        // a sibling for the node to merge/balance with.
        assert(parent->slotuse >= 1);
        uint16_t rightSlot = uint16_t(parentSlot + 1);
        uint16_t leftSlot = uint16_t(parentSlot - 1);

        /// Case 1: There is only the right sibling to merge/balance with
        if (parentSlot == 0) {
            NodeId rightId = parent->getChildAt(rightSlot);
            Node *right = readNode(rightId, &buffer);

            // Edge case where current key was updated in the current delete op
            BtreeEntry currParentKey = (info->lastEntryUpdated)
                    ? info->lastEntry : parent->getAt(parentSlot);

            if (right->isfew()) {
                merge(curr, right, currParentKey);
                info->op = info->delCurr;
                writeNode(right, rightId);
                freeNode(currId);
            } else {
                BtreeEntry newLastKey = balance(curr, right, currParentKey);
                info->op = info->setCurr;
                info->setSetEntry(newLastKey);
                writeNode(curr, currId);
                writeNode(right, rightId);
            }
        }
        // Case 2: There is only left sibling to merge/balance with.
        else if (parentSlot == parent->slotuse) {
            NodeId leftId = parent->getChildAt(leftSlot);
            Node *left = readNode(leftId, &buffer);
            BtreeEntry leftParentKey = parent->getAt(leftSlot);

            if (left->isfew()) {
                merge(left, curr, leftParentKey);
                info->op = info->delLeft;
                writeNode(curr, currId);
                freeNode(leftId);
            } else {
                BtreeEntry newLastKey = balance(left, curr, leftParentKey);
                info->op = info->setLeft;
                info->setSetEntry(newLastKey);
                writeNode(left, leftId);
                writeNode(curr, currId);
            }
        }
        // Case 3: Both siblings exist
        else {
            NodeId leftId = parent->getChildAt(leftSlot);
            NodeId rightId = parent->getChildAt(rightSlot);
            Node *left = readNode(leftId, &buffer);
            Node *right = readNode(rightId, &buffer);
            BtreeEntry leftParentKey = parent->getAt(leftSlot);

            // Edge case where current key was updated in the current delete op
            BtreeEntry currParentKey =
                    (info->lastEntryUpdated) ? info->lastEntry : parent->getAt(parentSlot);

            // Case 3a: Right is about to underflow so merge with it.
            if (right->isfew()) {
                merge(curr, right, currParentKey);
                info->op = info->delCurr;
                writeNode(right, rightId);
                freeNode(currId);
            }
            // Case 3b: Left is about to underflow so merge with it
            else if(left->isfew()) {
                merge(left, curr, leftParentKey);
                info->op = info->delLeft;
                writeNode(curr, currId);
                freeNode(leftId);
            }
            // Case 3c: Both left and right has extras, so balance with the
            // one with more extras.
            else if (left->slotuse >= right->slotuse) {
                BtreeEntry newLastKey = balance(left, curr, leftParentKey);
                info->op = info->setLeft;
                info->setSetEntry(newLastKey);
                writeNode(left, leftId);
                writeNode(curr, currId);
            } else {
                BtreeEntry newLastKey = balance(curr, right, currParentKey);
                info->op = info->setCurr;
                info->setSetEntry(newLastKey);
                writeNode(right, rightId);
                writeNode(curr, currId);
            }
        }

        // If merge occurred, decrement the node count
        if (info->op == info->delCurr || info->op == info->delLeft) {
            if (curr->level == 0) {
                m_stats.leaves--;
            } else {
                m_stats.innernodes--;
            }
        }
    }

    /**
     * Demuxes a balance call depending on whether the nodes are inner
     * or leaf nodes. After this call, both nodes should have about the
     * same entries (+/-1).
     *
     * Note: This exists to prevent handleUnderflow from becoming
     * too unwieldy with if statements.
     *
     * \param left
     *      The left node to balance with
     *
     * \param right
     *      The right node to balance with
     *
     * \param leftParentEntry
     *      The entry stored in the parent indexing the left node.
     *
     * \return
     *     BtreeEntry that should be used to update the parent's entry
     *     for the left node.
     */
    inline BtreeEntry
    balance(Node *left, Node *right, BtreeEntry leftParentEntry)
    {
        PerfStats::threadStats.btreeRebalances++;

        if (left->isinnernode()) {
            InnerNode *leftIn = static_cast<InnerNode*>(left);
            InnerNode *rightIn = static_cast<InnerNode*>(right);
            return leftIn->balanceWithRight(rightIn, leftParentEntry);
        } else {
            LeafNode *leafLeaf = static_cast<LeafNode*>(left);
            LeafNode *rightLeaf = static_cast<LeafNode*>(right);
            return leafLeaf->balanceWithRight(rightLeaf);
        }
    }

    /**
     * Demuxes a merge call depending on whether the nodes are inner
     * or leaf nodes. After this call, the left node will be empty and
     * all the entries will be moved into the right node. If leaf nodes
     * are passed in, their siblings pointers will be adjusted.
     *
     * Note: This exists to prevent handleUnderflow from becoming
     * too unwieldy with if statements.
     *
     * \param left
     *      The left node to merge with
     *
     * \param right
     *      The right node to merge with
     *
     * \param leftParentEntry
     *      The entry stored in the parent indexing the left node.
     */
    inline void
    merge(Node *left, Node *right, BtreeEntry leftParentEntry)
    {
        PerfStats::threadStats.btreeNodeCoalesces++;

        // If these are leaf nodes, we need to adjust pointers
        if (left->isLeaf()) {
            LeafNode *leftLeaf = static_cast<LeafNode*>(left);
            LeafNode *rightLeaf = static_cast<LeafNode*>(right);
            leftLeaf->mergeIntoRight(rightLeaf);

            rightLeaf->prevleaf = leftLeaf->prevleaf;
            if (leftLeaf->prevleaf != INVALID_NODEID) {
                Buffer buffer;
                LeafNode *prev = static_cast<LeafNode*>(
                          readNode(leftLeaf->prevleaf, &buffer));
                prev->nextleaf = leftLeaf->nextleaf;
                writeNode(prev, leftLeaf->prevleaf);
            }
        } else {
            InnerNode *leftInner = static_cast<InnerNode*>(left);
            InnerNode *rightInner = static_cast<InnerNode*>(right);
            leftInner->mergeIntoRight(rightInner, leftParentEntry);
        }
    }

        // *** Debugging Functions
PUBLIC:
    /**
     * Runs a thorough verification of all B+ tree invariants by performing a
     * traversal and returns a human readable string indicating the first error
     * found. An empty string indicates a consistent B+ tree.
     *
     * If called with checkStats = true, the tree stats will be rebuilt
     * instead of checked against.
     *
     * \param checkStats
     *      if true, stats will be checked to make sure they're correct.
     *      if false, sets the stats since verify() will do a full traversal
     *
     * \return
     *      Human readable string indicating errors.
     */
    string
    verify(bool checkStats = false)
    {
        std::stringstream ss;
        Buffer keyBuffer;
        BtreeEntry minkey, maxkey;
        tree_stats vstats;

        if (nextNodeId > ROOT_ID) {
            return verify_node(m_rootId, &minkey, &maxkey, &keyBuffer,
                    vstats, true);

            if (checkStats) {
                // Note, these will fail after recovery/migration
                if (vstats.itemcount != m_stats.itemcount) {
                    ss << "Item count not correct expected="
                            << vstats.itemcount
                            << " , actual="
                            << m_stats.itemcount
                            << "\r\n";
                }

                if (vstats.leaves == m_stats.leaves) {
                     ss << "Leaf node count not correct expected="
                            << vstats.leaves
                            << " , actual="
                            << m_stats.leaves
                            << "\r\n";
                }

                if (vstats.innernodes == m_stats.innernodes) {
                    ss << "Inner node count not correct expected="
                            << vstats.innernodes
                            << " , actual="
                            << m_stats.innernodes
                            << "\r\n";
                }
            } else {
                m_stats.itemcount = vstats.itemcount;
                m_stats.leaves = vstats.leaves;
                m_stats.innernodes = vstats.innernodes;
            }
        }

        return "";
    }

    /**
     * Preforms a breath first traversal of the tree and returns a string
     * representation of the tree.
     *
     * \return
     *      string representation of the tree
     */
    string
    toString()
    {
        std::ostringstream output;

        // Do a breath first print of the tree
        std::deque<NodeId> toVisit;
        toVisit.push_back(ROOT_ID);

        if (nextNodeId <= ROOT_ID) {
            return "Empty Tree!\r\n";
        }

        Buffer buff;
        uint16_t level = 0;
        while (!toVisit.empty()) {
            NodeId curr = toVisit.front();
            toVisit.pop_front();
            buff.reset();

            const Node *node = this->readNode(curr, &buff);
            if (node->level != level) {
                level = node->level;
                output << "=================== NEW LEVEL ("
                    << level << ") ====================\r\n";
            }

            output << "NodeID: " << curr << "\r\n";
            output << node->toString();

            if (node->isinnernode()) {
                const InnerNode *inner = static_cast<const InnerNode*>(node);
                for (uint16_t i = 0; i < inner->slotuse + 1; i++) {
                    toVisit.push_back(inner->getChildAt(i));
                }
            }
        }

        return output.str();
    }

    /**
     * Preforms a breath first traversal of the tree and prints a human
     * readable string representation of the string to the logs. This function
     * is useful for cases where the B+ tree is so large it will no longer
     * fit in a single log message.
     *
     * \return
     *      string representation of the tree
     */
    void
    printToLog(enum LogLevel logLevel)
    {
        std::deque<NodeId> toVisit;
        toVisit.push_back(ROOT_ID);

        if (nextNodeId <= ROOT_ID) {
            RAMCLOUD_LOG(logLevel, "Empty Tree!");
            return;
        }

        Buffer buff;
        uint16_t level = 0;
        while (!toVisit.empty()) {
            NodeId curr = toVisit.front();
            toVisit.pop_front();
            buff.reset();

            const Node *node = this->readNode(curr, &buff);
            if (node->level != level) {
                level = node->level;
                RAMCLOUD_LOG(logLevel, "=================== "
                        "NEW LEVEL (%u) ====================", level);
            }

            RAMCLOUD_LOG(logLevel, "NodeID: %lu\r\n%s", curr, node->toString().c_str());

            if (node->isinnernode()) {
                const InnerNode *inner = static_cast<const InnerNode*>(node);
                for (uint16_t i = 0; i < inner->slotuse + 1; i++) {
                    toVisit.push_back(inner->getChildAt(i));
                }
            }
        }
    }

     /**
     * STL-like backwards and forwards iterator object for B+ tree entries.
     * A forward iterator will iterate in increasing order while a backwards
     * iterator will traverse in decreasing order.
     *
     * The iterator itself is invalidated upon modification/migration/recovery
     * of the btree, but most importantly the entry returned is invalidated
     * when advancing or decrementing the iterator.
     */
    class iterator {
        /// STL-magic - iterator category
        typedef std::bidirectional_iterator_tag iterator_category;

        /**
         * The iterator works by traversing the the leaf nodes using their
         * next/prev NodeId pointers.
         */

    PRIVATE:
        /// Pointer to the B+ tree that this iterator is traversing
        IndexBtree* parentBtree;

        /// NodeId of the currently referenced leaf node in the tree
        NodeId currentNodeId;

        /// Current key/data slot referenced within the node.
        uint16_t currslot;

        /// Holds the contents of the currently referenced leaf
        Buffer buffer;

        /// Pointer to the currently referenced leaf node within the Buffer
        const LeafNode* currnode;

        /// A temporary entry to STL-correctly deliver operator* and operator->
        BtreeEntry tempEntry;

    PUBLIC:
        /**
         * Constructs an invalid iterator, aka end()
         */
        inline iterator(IndexBtree* tree = NULL)
            : parentBtree(tree), currentNodeId(INVALID_NODEID), currslot(0),
              buffer(), currnode(NULL), tempEntry()
        { }

        /**
         * Constructs an iterator with a starting point within a B+ tree
         * \param tree
         *      IndexBtree this will be iterating over
         *
         * \param nodeId
         *      NodeId to the start of the iterator at
         *
         * \param slot
         *      slot within the node to start the iterator at
         */
        inline iterator(IndexBtree *tree, NodeId nodeId, uint16_t slot = 0)
            : parentBtree(tree), currentNodeId(nodeId), currslot(slot),
              buffer(), currnode(NULL), tempEntry()
        { }

        inline iterator(const iterator &it)
            : parentBtree(it.parentBtree),
              currentNodeId(it.currentNodeId),
              currslot(it.currslot),
              buffer(), currnode(NULL), tempEntry()
        { }

        /// Implement the = operator to avoid invocation of the operator=
        /// method on the Buffer class which does not exist
        inline iterator&
        operator=(const iterator &it)
        {
            parentBtree = it.parentBtree;
            currentNodeId = it.currentNodeId;
            currslot = it.currslot;
            buffer.reset();
            currnode = NULL;
            return *this;
        }

        inline ~iterator() { }

        /// Dereference the iterator
        inline BtreeEntry&
        operator*()
        {
            if (!currnode)
                  currnode = static_cast<const LeafNode *>(
                        parentBtree->readNode(currentNodeId, &buffer));

            tempEntry = currnode->getAt(currslot);
            return tempEntry;
        }

        /// Dereference the iterator
        inline BtreeEntry*
        operator->()
        {
            if (!currnode)
                currnode = static_cast<const LeafNode *>(
                        parentBtree->readNode(currentNodeId, &buffer));

            tempEntry = currnode->getAt(currslot);
            return &tempEntry;
        }

        /// Prefix++ advance the iterator to the next slot.
        /// Note: This invalidates values returned by any previous dereferences.
        inline iterator&
        operator++()
        {
            if (!currnode)
                currnode = static_cast<const LeafNode*>(
                        parentBtree->readNode(currentNodeId, &buffer));


            if (currslot + 1 < currnode->slotuse) {
                ++currslot;
            } else if (currnode->nextleaf != INVALID_NODEID) {
                currentNodeId = currnode->nextleaf;
                currslot = 0;
                currnode = NULL;
                buffer.reset();
            } else {
                // this is end()
                currentNodeId = INVALID_NODEID;
                currslot = 0;
                buffer.reset();
                currnode = NULL;
            }

            return *this;
        }

        /// Postfix++ advance the iterator to the next slot
        /// Note: This invalidates values returned by any previous dereferences.
        inline iterator
        operator++(int)
        {
            iterator tmp = *this;   // copy ourselves

            if (!currnode)
                currnode = static_cast<const LeafNode*>(
                        parentBtree->readNode(currentNodeId, &buffer));

            if (currslot + 1 < currnode->slotuse) {
                ++currslot;
            } else if (currnode->nextleaf != INVALID_NODEID) {
                currentNodeId = currnode->nextleaf;
                currslot = 0;
                buffer.reset();
                currnode = NULL;
            } else {
                // this is end()
                currentNodeId = INVALID_NODEID;
                currslot = 0;
                buffer.reset();
                currnode = NULL;
            }

            return tmp;
        }

        /// Prefix-- backstep the iterator to the last slot
        /// Note: This invalidates values returned by any previous dereferences.
        inline iterator&
        operator--()
        {
            if (!currnode)
                currnode = static_cast<const LeafNode*>(
                        parentBtree->readNode(currentNodeId, &buffer));

            if (currslot > 0) {
                --currslot;
            } else if (currnode->prevleaf != INVALID_NODEID) {
                currentNodeId = currnode->prevleaf;
                currslot = uint16_t(currnode->slotuse - 1);
                buffer.reset();
                currnode = NULL;
            } else {
                // this is begin()
                currslot = 0;
                buffer.reset();
                currnode = NULL;
            }

            return *this;

        }

        /// Postfix-- backstep the iterator to the last slot
        /// Note: This invalidates values returned by any previous dereferences.
        inline iterator
        operator--(int)
        {
            iterator tmp = *this;   // copy ourselves

            if (!currnode)
                currnode = static_cast<const LeafNode*>(
                        parentBtree->readNode(currentNodeId, &buffer));

            if (currslot > 0) {
                --currslot;
            } else if (currnode->prevleaf != INVALID_NODEID) {
                currentNodeId = currnode->prevleaf;
                currslot = uint16_t(currnode->slotuse - 1);
                buffer.reset();
                currnode = NULL;
            } else {
                // this is begin()
                currslot = 0;
                buffer.reset();
                currnode = NULL;
            }

            return tmp;
        }

        /// Equality of iterators
        inline bool
        operator==(const iterator& x) const
        {
            return (x.parentBtree == parentBtree)
                    &&(x.currentNodeId == currentNodeId)
                    && (x.currslot == currslot);
        }

        /// Inequality of iterators
        inline bool
        operator!=(const iterator& x) const
        {
            return !operator==(x);
        }
    };

PRIVATE:
    /**
     * Recursively descend the B+ tree starting at a given nodeId and verify
     * all B+ tree invariants on the subtree.
     *
     * \param nodeId
     *      Starting point for verification i.e. root
     *
     * \param[out] minkey
     *      The minimum key in the subtree
     *
     * \param[out] maxkey
     *      The maximum key in the subtree
     *
     * \param[out] keyBuffer
     *      Used to store the variable length keys of minkey/maxkey
     *
     * \param[out] vstats
     *      The stats (such as # of items) calculated for the subtree on descent
     *
     * \param nodeIsAlongRightMostPath
     *      The node is situated along the path to the largest key in the tree.
     *      Set to false if one is unsure.
     *
     * \return
     *      A human readable string specifying an error in the Btree.
     *      Empty string means that no invariants are violated
     */
    string
    verify_node(NodeId nodeId, BtreeEntry *minkey, BtreeEntry *maxkey,
                        Buffer *keyBuffer, tree_stats &vstats,
                        bool nodeIsAlongRightMostPath = false) const
    {
        Buffer buffer;
        std::ostringstream errors;
        Node* n = readNode(nodeId, &buffer);
        if (n == NULL) {
            errors << "There's a broken link in the tree. Cannot find node" <<
                    nodeId;
            return errors.str();
        }

        if (nodeId != ROOT_ID && n->isunderflow()) {
            errors << "Node " << nodeId << " has underflowed "
                 << "and it is not the root. \r\n" << n->toString();
            return errors.str();
        }

        if (n->slotuse == 0) {
            errors << "Node " << nodeId << " is empty. \r\n";
            return errors.str();
        }

        for (uint16_t slot = 0; slot < n->slotuse - 1; ++slot) {
          if (!key_lessequal(n->getAt(slot), n->getAt(uint16_t(slot + 1)))) {
              errors << "Node " << nodeId << "'s contents are not"
                      << " in sorted order.\r\n" << n->toString();
              return errors.str();
          }
        }

        if (n->isLeaf()) {
            const LeafNode *leaf = static_cast<const LeafNode*>(n);

            *minkey = leaf->getAt(0, keyBuffer);
            uint16_t maxSlot = (leaf->slotuse == 0) ?
                uint16_t(0) : uint16_t(leaf->slotuse - 1);
            *maxkey = leaf->getAt(maxSlot, keyBuffer);

            vstats.leaves++;
            vstats.itemcount += leaf->slotuse;
        }
        else // !n->isleafnode()
        {
            const InnerNode *inner = static_cast<const InnerNode*>(n);
            vstats.innernodes++;

            if (nodeIsAlongRightMostPath) {
                if (!inner->rightMostLeafKeyIsInfinite) {
                    errors << "Inner node ("
                            << nodeId
                            << ") is supposedly along the path to the largest"
                            << " key in the tree, yet rightMostLeafKeyIsInfinte"
                            << " is false."
                            << "\r\n";
                    return errors.str();
                }
            } else {
                BtreeEntry rightmostLeafKey = inner->getRightMostLeafKey();
                if (!key_lessequal(inner->back(), rightmostLeafKey)) {
                    errors << "Inner node ("
                            << nodeId
                            << ") rightmost leaf key variable "
                            << rightmostLeafKey.toString()
                            << " is not greater than or equal to the last key"
                            << " in the node "
                            << inner->getAt(uint16_t(n->slotuse - 1)).toString()
                            << "\r\n";
                    return errors.str();
                }
            }

            for(uint16_t slot = 0; slot <= inner->slotuse; ++slot) {
                Buffer subnodeBuffer;
                NodeId subnodeId = inner->getChildAt(slot);
                const Node* subnode = readNode(subnodeId, &subnodeBuffer);
                BtreeEntry subminkey,submaxkey;

                if (subnode->level + 1 != inner->level) {
                    errors << "Parent Node " << nodeId << "'s Child Node "
                            << subnodeId << " does not have the right level "
                            << "field. Parent level = " << inner->level
                            << " Child level = " << subnode->level
                            << "\r\nChild: " << subnode->toString()
                            << "\r\nParent: " << inner->toString();
                    return errors.str();
                }

                bool isChildAlongRightMostPath =
                        nodeIsAlongRightMostPath && (slot == inner->slotuse);
                string errorsFromBelow =
                        verify_node(subnodeId, &subminkey, &submaxkey,
                                keyBuffer, vstats, isChildAlongRightMostPath);

                // Add our information the unwind
                if (errorsFromBelow.length() > 0) {
                    errors << errorsFromBelow << "== Level "
                            << inner->level << " NodeId " << nodeId << " =="
                            << inner->toString();

                    return errors.str();
                }

                if (slot == 0)
                    *minkey = subminkey;
                else if (!key_greaterequal(subminkey,
                                           inner->getAt(uint16_t(slot - 1)))) {
                    errors << "The key at slot " << slot << " of inner node "
                            << nodeId << " is not greater than the left most "
                            << "key in the subtree " << subminkey.toString()
                            << "\r\n";
                    return errors.str();
                }

                if (slot == inner->slotuse) {
                    *maxkey = submaxkey;

                    BtreeEntry rightmost = inner->getRightMostLeafKey();
                    if (!inner->rightMostLeafKeyIsInfinite &&
                            !key_greaterequal(rightmost, submaxkey)) {
                        errors << "Inner Node " << nodeId << " rightmost key "
                                << rightmost.toString()
                                << " not greater or equal to "
                                << "to rightmost leaf key "
                                << submaxkey.toString() << " at slot " << slot
                                << "/r/n";
                        return errors.str();
                    }
                } else {
                    if (!key_greaterequal(inner->getAt(slot), submaxkey)) {
                        errors << "Inner Node " << nodeId << " key not equal "
                                << "to rightmost leaf key "
                                << submaxkey.toString() << " at slot " << slot
                                << "/r/n";
                        return errors.str();
                    }
                }

                if (inner->level == 1 && slot < inner->slotuse) {
                    // children are leaves and must be linked together in the
                    // correct order
                    Buffer firstBuffer, secondBuffer;
                    NodeId leftId = inner->getChildAt(slot);
                    NodeId rightId = inner->getChildAt(uint16_t(slot + 1));
                    const LeafNode *left = static_cast<const LeafNode*>(
                                                    readNode(
                                                    leftId, &firstBuffer));
                    const LeafNode *right = static_cast<const LeafNode*>(
                                                    readNode(
                                                    rightId, &secondBuffer));

                    if (left->nextleaf != rightId
                            || right->prevleaf != leftId) {
                        errors << "Leaf nodes " << leftId << " and " << rightId
                                << " are not properly linked together.\r\n"
                                << "Left Child: " << left->toString()
                                << "Right Child: " << right->toString()
                                << "Parent: " << inner->toString();

                        return errors.str();
                    }
                } else if (inner->level == 2 && slot < inner->slotuse) {
                    // verify leaf links between the adjacent inner nodes
                    Buffer firstBuffer, secondBuffer, thirdBuffer, fourthBuffer;
                    const InnerNode* lparent = static_cast<const InnerNode*>(
                            readNode(inner->getChildAt(slot), &firstBuffer));
                    const InnerNode *rparent = static_cast<const InnerNode*>(
                            readNode(inner->getChildAt(
                                        uint16_t(slot + 1)), &secondBuffer));

                    NodeId leftId = lparent->getChildAt(lparent->slotuse);
                    NodeId rightId = rparent->getChildAt(0);
                    const LeafNode *left = static_cast<const LeafNode*>(
                                                    readNode(
                                                    leftId, &thirdBuffer));
                    const LeafNode *right = static_cast<const LeafNode*>(
                                                    readNode(
                                                    rightId, &fourthBuffer));

                     if (left->nextleaf != rightId
                            || right->prevleaf != leftId) {
                        errors << "Leaf nodes " << leftId << " and " << rightId
                                << " are not properly linked together.\r\n"
                                << "Left Child: " << left->toString()
                                << "Right Child: " << right->toString()
                                << "Left Parent: " << lparent->toString()
                                << "Right Parent: " << rparent->toString()
                                << "== Level " << inner->level
                                << " NodeId " << nodeId << " =="
                                << inner->toString();

                        return errors.str();
                    }
                }
            }
        }

        return ""; // No errors
    }
};

} // namespace RAMCloud

#endif // _STR_BTREE_H_
