This document shall outline how to edit the libmemcached-1.0.13 sources to make it RAMCloud compatible. The implementation described is simplistic. It is single threaded, stores data in only one table, and only allows for set/get semantics. The purpose of this document is not to provide a comprehensive guide, but rather to give a flavor on how to edit the libmemcached sources (although it shouldn’t be hard to expand the guide’s implementation to include multithreading and storing data in multiple tables based on key prefixes).  

The guide is split into 2 parts: Part one describes core modifications needed to support intercepting get/set commands and translating them to RAMCloud read/writes with English explanations. Part two is the diff of our implementation with the libmemcached source base which includes both the core modifications above and additional modifications to integrate RAMCloud into memslap with the ability to switch between memslapping a memcached server and a RAMCloud cluster. The instructions on how to start a cluster and use the command args for memslap are also in part 2. 

#######   Part 1 – Core Modifications   #######
---- MakeFile ----
The make file is generated by an automake file. One should ideally edit automake to reflect the following changes, but below we will instead detail how to manually edit the make file to include a libramcloud.a file. 

1)	Make the make file with ./configure in the terminal
2)	Open Makefile and find the line that starts with “CXXFLAGS = ” and append to it “-I<ramcloudSrcDir> -lramcloud  -L<ramcloudLibDir> -lstdc++ -lpcrecpp -lprotobuf -libverbs -lrt” 

where <ramcloudSrcDir> is the directory of your RAMCloud sources and <ramcloudLIbDir> is where your libramcloud.a is located. The rest of the arguments are for RAMCloud dependences such as Infiniband. 

---- Adding a rc_client ----
Libmemcached keeps all the client metadata in struct memcached_st located in memcached.h. In that struct, add these three lines
  struct rc_client *ramcloud;
  uint64_t tableId;
  char value[1024*1024];

The first line gives us a place to store a ramcloud client. Second line stores the single tableid that we will use to store all our response values. Note that this should probably be done some otherway, but this provides a quick and dirty way to get us running. Also remember to #include <CRamCloud.h> at the top of the file.

---- Creating the client ----
The best time to construct the client would probably be when libmemcached parses the server list. In our implementation, we assume that we pass in a single Coordinator locator instead of a list of memcached servers. 
In “hosts.cc”, find memcached_server_push(… Add to the very beginning:
  rc_connect(list[0].hostname, &(ptr->ramcloud));
  rc_createTable(ptr->ramcloud, "memcached");
  Status s = rc_getTableId(ptr->ramcloud, "memcached", &(ptr->tableId));
  if (s != STATUS_OK)
    return memcached_set_error(*ptr, MEMCACHED_CONNECTION_BIND_FAILURE, MEMCACHED_AT);

  return MEMCACHED_SUCCESS;

What this does is that we parse in the first hostname on the list and treat that as the coordinator locator. Alternatively, you can hardcode a coordinator locator here. Then we create a table named “memcached” and store the tableId in struct memcached_st. Also remember to #include <CRamCloud.h> at the top of the file. 

Note that if you do plan to parse servers that are passed into the argument, you need to also rip out the logic that interprets memcached-style server strings. 
In “parse.cc” replace the contents of “memcached_server_parse” with 
  memcached_server_st *servers= NULL;
  memcached_return_t rc;
  WATCHPOINT_ASSERT(server_strings);
  return memcached_server_list_append(servers, server_strings, 0, &rc);

This will pass in the raw server string to hosts.cc  without trying to interpreting them. Optionally, one can put options try to detect syntax errors with the server string here. 

---- Intercepting Gets ----
In get.cc, find “memcached_get(…” and replace its function contents with
  RejectRules rr;
  uint64_t ver;
  uint32_t size;
  Status s1 = rc_read(ptr->ramcloud, ptr->tableId, key, key_length, NULL, &ver,
           		 ptr->value, 1024*1024, &size);
 	*value_length = size;

  if (s1 == STATUS_OK)
    *error = MEMCACHED_SUCCESS;
  else
    *error = MEMCACHED_READ_FAILURE;
    
  *flags = 0;
  return ptr->value;

This translates a libmemcached get into a ramcloud read. A special note about something not shown here is that libmemcached frees the pointer that is returned when it is done. In this example, we're returning a pointer that should NOT be freed. Thus, the feee must be deleted. This free is located near the end of execute.cc::execute_get(… 
    ::free(value);
  }
  return retrieved;

However, if you use the diff files from below, that free is guarded by an if instead so that deletes only occur when using the memcached engine and not for RAMCloud. 

Also remember to #include <CRamCloud.h> at the top of the files.

---- Intercepting Sets ----
Inside storage.cc find “memcached_send(…” and replace its contents with:
  RejectRules rr;
  uint64_t version;
  Status s = rc_write(ptr->ramcloud, ptr->tableId, key, key_length, value,
              value_length, NULL, &version);

  if ( s == STATUS_OK)
    return MEMCACHED_SUCCESS;
  return MEMCACHED_WRITE_FAILURE;

This translates a libmemcached set into a ramcloud write. One note to be made is that certain CAS rules can be implemented with the RejectRules in RAMCloud. However, that is not shown here. Also remember to #include <CRamCloud.h> at the top of the file.  



#######   Part 2 – Client Args + Raw Diff   #######
---- How to Start A Cluster and use Memslap ----
*Starting a Cluster*
-> on rc01 run Coordinator
ramcloud/obj.master/coordinator -C infrc:host=192.168.0.101,port=11115

-> on rc02 run Master
ramcloud/obj.master/server -M -C infrc:host=192.168.0.101,port=11115 -L infrc:host=192.168.0.102,port=11114

*Running Memslap Write Test on RAMCloud*
libmemcached-1.0.13/clients/memslap --ramcloud --concurrency=1 --initial-load=50000 --execute-number=50000 --servers=infrc:host=192.168.0.101,port=11115 --test=set
***Note: concurrency must = 1 because threading is not supported in our RAMCloud/libmemcached implementation. 

*Running Memslap Write Test on Memcached to rc03*
libmemcached-1.0.13/clients/memslap --concurrency=1 --initial-load=50000 --execute-number=50000 --servers=192.168.0.103 --test=set 

*Running Memslap Read Test on RAMCloud*
clients/memslap --ramcloud --concurrency=1 --initial-load=50000 --servers=infrc:host=192.168.0.101,port=11115 --test=get

*Running Memslap Read Test on Memcached to rc03*
clients/memslap --concurrency=1 --initial-load=50000 --servers=192.168.0.103 --test=get 






---- Raw Diff ----
List of Files
	clients/client_options.h
	clients/execute.cc
	clients/memslap.cc
	clients/utilities.cc
	libmemcached/behavior.cc
	libmemcached/get.cc
	libmemcached/hosts.cc
	libmemcached/is.h
	libmemcached/memcached.cc
	libmemcached/parse.cc
	libmemcached/storage.cc
	libmemcached-1.0/struct/memcached.h
	libmemcached-1.0/types/behavior.h
	libmemcached-1.0/parse.h
	Makefile

*** libmemcached-1.0.13-vanilla/clients/client_options.h	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/clients/client_options.h	2012-10-22 22:10:53.407052790 -0700
***************
*** 34,39 ****
--- 34,40 ----
    OPT_FLUSH,
    OPT_HASH,
    OPT_BINARY,
+   OPT_RAMCLOUD,
    OPT_UDP,
    OPT_BUFFER,
    OPT_USERNAME,
*** libmemcached-1.0.13-vanilla/clients/execute.cc	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/clients/execute.cc	2012-10-23 04:44:51.000000000 -0700
***************
*** 34,40 ****
                __FILE__, __LINE__,
                memcached_last_error_message(memc),
                (unsigned int)pairs[x].key_length, pairs[x].key);
!       
        // We will try to reconnect and see if that fixes the issue
        memcached_quit(memc);
      }
--- 34,40 ----
                __FILE__, __LINE__,
                memcached_last_error_message(memc),
                (unsigned int)pairs[x].key_length, pairs[x].key);
! 
        // We will try to reconnect and see if that fixes the issue
        memcached_quit(memc);
      }
***************
*** 80,85 ****
--- 80,88 ----
        retrieved++;
      }
  
+     if (memc->flags.ramcloud_protocol)
+         continue;
+ 
      ::free(value);
    }
  
*** libmemcached-1.0.13-vanilla/clients/memslap.cc	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/clients/memslap.cc	2012-10-25 03:06:05.028802379 -0700
***************
*** 1,5 ****
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  * 
   *  Libmemcached library
   *
   *  Copyright (C) 2011-2012 Data Differential, http://datadifferential.com/
--- 1,5 ----
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  *
   *  Libmemcached library
   *
   *  Copyright (C) 2011-2012 Data Differential, http://datadifferential.com/
***************
*** 145,150 ****
--- 145,151 ----
  void flush_all(memcached_st *memc);
  
  static bool opt_binary= 0;
+ static bool opt_ramcloud= 0;
  static int opt_verbose= 0;
  static int opt_flush= 0;
  static int opt_non_blocking_io= 0;
***************
*** 219,225 ****
      }
    }
  
!   memcached_server_st *servers= memcached_servers_parse(opt_servers);
  
    pthread_mutex_init(&sleeper_mutex, NULL);
    pthread_cond_init(&sleep_threshhold, NULL);
--- 220,231 ----
      }
    }
  
!   memcached_server_st *servers;
! 
!   if (opt_ramcloud)
!     servers = ramcloud_servers_parse(opt_servers);
!   else
!     servers = memcached_servers_parse(opt_servers);
  
    pthread_mutex_init(&sleeper_mutex, NULL);
    pthread_cond_init(&sleep_threshhold, NULL);
***************
*** 245,250 ****
--- 251,259 ----
  
    memcached_st *memc= memcached_create(NULL);
  
+   memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_RAMCLOUD_PROTOCOL,
+                          (uint64_t)opt_ramcloud);
+ 
    memcached_server_push(memc, servers);
  
    /* We need to set udp behavior before adding servers to the client */
***************
*** 260,266 ****
  
    memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL,
                           (uint64_t)opt_binary);
- 
    if (opt_flush)
    {
      flush_all(memc);
--- 269,274 ----
***************
*** 322,328 ****
  
      if (opt_test == SET_TEST)
      {
!       context->execute_pairs= pairs_generate(opt_execute_number, 400);
        context->execute_number= opt_execute_number;
      }
  
--- 330,337 ----
  
      if (opt_test == SET_TEST)
      {
!         //TODO(RAMCloud) SET_VALUE_SIZE=400 was modified to test a hard 100-byte value limit. 
!       context->execute_pairs= pairs_generate(opt_execute_number, 100);
        context->execute_number= opt_execute_number;
      }
  
***************
*** 381,386 ****
--- 390,396 ----
        {(OPTIONSTRING)"verbose", no_argument, &opt_verbose, OPT_VERBOSE},
        {(OPTIONSTRING)"version", no_argument, NULL, OPT_VERSION},
        {(OPTIONSTRING)"binary", no_argument, NULL, OPT_BINARY},
+       {(OPTIONSTRING)"ramcloud", no_argument, NULL, OPT_RAMCLOUD},
        {(OPTIONSTRING)"udp", no_argument, NULL, OPT_UDP},
        {0, 0, 0, 0},
      };
***************
*** 413,418 ****
--- 423,432 ----
        opt_binary= true;
        break;
  
+    case OPT_RAMCLOUD:
+        opt_ramcloud= true;
+      break;
+ 
      case OPT_VERBOSE: /* --verbose or -v */
        opt_verbose= OPT_VERBOSE;
        break;
***************
*** 534,540 ****
    /* We always used non-blocking IO for load since it is faster */
    memcached_behavior_set(memc_clone, MEMCACHED_BEHAVIOR_NO_BLOCK, 0);
  
!   pairs_st *pairs= pairs_generate(number_of, 400);
    *actual_loaded= execute_set(memc_clone, pairs, number_of);
  
    memcached_free(memc_clone);
--- 548,555 ----
    /* We always used non-blocking IO for load since it is faster */
    memcached_behavior_set(memc_clone, MEMCACHED_BEHAVIOR_NO_BLOCK, 0);
  
!   //TODO(RAMCloud) preload VALUE_LEN=400 was changed to do 100-byte objects
!   pairs_st *pairs= pairs_generate(number_of, 100);
    *actual_loaded= execute_set(memc_clone, pairs, number_of);
  
    memcached_free(memc_clone);
*** libmemcached-1.0.13-vanilla/clients/utilities.cc	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/clients/utilities.cc	2012-10-22 22:11:19.190045928 -0700
***************
*** 97,102 ****
--- 97,103 ----
    case OPT_FLUSH: return("Flush servers before running tests.");
    case OPT_HASH: return("Select hash type.");
    case OPT_BINARY: return("Switch to binary protocol.");
+   case OPT_RAMCLOUD: return("Use Ramcloud Client");
    case OPT_ANALYZE: return("Analyze the provided servers.");
    case OPT_UDP: return("Use UDP protocol when communicating with server.");
    case OPT_BUFFER: return("Enable request buffering.");
*** libmemcached-1.0.13-vanilla/libmemcached/behavior.cc	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/libmemcached/behavior.cc	2012-10-23 01:09:09.739018143 -0700
***************
*** 1,5 ****
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  * 
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
--- 1,5 ----
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  *
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
***************
*** 124,129 ****
--- 124,139 ----
      ptr->flags.binary_protocol= bool(data);
      break;
  
+   case MEMCACHED_BEHAVIOR_RAMCLOUD_PROTOCOL:
+     send_quit(ptr); // We need t shutdown all of the connections to make sure we do the correct protocol
+     if (data)
+     {
+       ptr->flags.verify_key= false;
+     }
+     ptr->flags.binary_protocol = false;
+     ptr->flags.ramcloud_protocol = bool(data);
+     break;
+ 
    case MEMCACHED_BEHAVIOR_SUPPORT_CAS:
      ptr->flags.support_cas= bool(data);
      break;
*** libmemcached-1.0.13-vanilla/libmemcached/get.cc	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/libmemcached/get.cc	2012-10-23 19:29:42.113972239 -0700
***************
*** 1,5 ****
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  * 
   *  Libmemcached library
   *
   *  Copyright (C) 2011-2012 Data Differential, http://datadifferential.com/
--- 1,5 ----
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  *
   *  Libmemcached library
   *
   *  Copyright (C) 2011-2012 Data Differential, http://datadifferential.com/
***************
*** 36,41 ****
--- 36,42 ----
   */
  
  #include <libmemcached/common.h>
+ #include <CRamCloud.h>
  
  /*
    What happens if no servers exist?
***************
*** 46,53 ****
                      uint32_t *flags,
                      memcached_return_t *error)
  {
!   return memcached_get_by_key(ptr, NULL, 0, key, key_length, value_length,
                                flags, error);
  }
  
  static memcached_return_t memcached_mget_by_key_real(memcached_st *ptr,
--- 47,74 ----
                      uint32_t *flags,
                      memcached_return_t *error)
  {
!   if (!memcached_is_ramcloud(ptr)) {
!       return memcached_get_by_key(ptr, NULL, 0, key, key_length, value_length,
                                flags, error);
+   }
+ 
+   //TODO(RAMCloud) There are a lot of hard-coded variables here.
+   RejectRules rr;
+   uint64_t ver;
+   uint32_t size;
+     Status s1 = rc_read(ptr->ramcloud, ptr->tableId, key, key_length, NULL, &ver,
+             ptr->value, 1024*1024, &size);
+ 
+     *value_length = size;
+ 
+     if (s1 == STATUS_OK)
+         *error = MEMCACHED_SUCCESS;
+     else
+         *error = MEMCACHED_READ_FAILURE;
+ 
+     *flags = 0;
+ 
+     return ptr->value;
  }
  
  static memcached_return_t memcached_mget_by_key_real(memcached_st *ptr,
***************
*** 80,86 ****
  
    /* Request the key */
    *error= memcached_mget_by_key_real(ptr, group_key, group_key_length,
!                                      (const char * const *)&key, &key_length, 
                                       1, false);
    if (ptr)
    {
--- 101,107 ----
  
    /* Request the key */
    *error= memcached_mget_by_key_real(ptr, group_key, group_key_length,
!                                      (const char * const *)&key, &key_length,
                                       1, false);
    if (ptr)
    {
***************
*** 97,103 ****
        }
      }
  
!     if (value_length) 
      {
        *value_length= 0;
      }
--- 118,124 ----
        }
      }
  
!     if (value_length)
      {
        *value_length= 0;
      }
*** libmemcached-1.0.13-vanilla/libmemcached/hosts.cc	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/libmemcached/hosts.cc	2012-10-23 02:06:51.662057328 -0700
***************
*** 1,5 ****
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  * 
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
--- 1,5 ----
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  *
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
***************
*** 36,41 ****
--- 36,42 ----
   */
  
  #include <libmemcached/common.h>
+ #include <CRamCloud.h>
  
  #include <cmath>
  #include <sys/time.h>
***************
*** 249,255 ****
  
          if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0)
          {
!           return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT, 
                                       memcached_literal_param("snprintf(sizeof(sort_host))"));
          }
  
--- 250,256 ----
  
          if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0)
          {
!           return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,
                                       memcached_literal_param("snprintf(sizeof(sort_host))"));
          }
  
***************
*** 302,308 ****
  
          if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0)
          {
!           return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT, 
                                       memcached_literal_param("snprintf(sizeof(sort_host)))"));
          }
  
--- 303,309 ----
  
          if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0)
          {
!           return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,
                                       memcached_literal_param("snprintf(sizeof(sort_host)))"));
          }
  
***************
*** 344,350 ****
    return MEMCACHED_SUCCESS;
  }
  
! static memcached_return_t server_add(memcached_st *ptr, 
                                       const memcached_string_t& hostname,
                                       in_port_t port,
                                       uint32_t weight,
--- 345,351 ----
    return MEMCACHED_SUCCESS;
  }
  
! static memcached_return_t server_add(memcached_st *ptr,
                                       const memcached_string_t& hostname,
                                       in_port_t port,
                                       uint32_t weight,
***************
*** 395,400 ****
--- 396,413 ----
  
  memcached_return_t memcached_server_push(memcached_st *ptr, const memcached_server_list_st list)
  {
+   if (memcached_is_ramcloud(ptr)) {
+       //TODO(RAMCloud) not the best place to put it, but no better place really.
+       rc_connect(list[0].hostname, &(ptr->ramcloud));
+       rc_createTable(ptr->ramcloud, "memcached");
+       Status s = rc_getTableId(ptr->ramcloud, "memcached", &(ptr->tableId));
+ 
+       if (s != STATUS_OK)
+         return memcached_set_error(*ptr, MEMCACHED_CONNECTION_BIND_FAILURE, MEMCACHED_AT);
+ 
+       return MEMCACHED_SUCCESS;
+   }
+ 
    if (list == NULL)
    {
      return MEMCACHED_SUCCESS;
***************
*** 423,429 ****
      WATCHPOINT_ASSERT(instance);
  
      memcached_string_t hostname= { memcached_string_make_from_cstr(list[x].hostname) };
!     if (__instance_create_with(ptr, instance, 
                                 hostname,
                                 list[x].port, list[x].weight, list[x].type) == NULL)
      {
--- 436,442 ----
      WATCHPOINT_ASSERT(instance);
  
      memcached_string_t hostname= { memcached_string_make_from_cstr(list[x].hostname) };
!     if (__instance_create_with(ptr, instance,
                                 hostname,
                                 list[x].port, list[x].weight, list[x].type) == NULL)
      {
***************
*** 473,479 ****
      WATCHPOINT_ASSERT(instance);
  
      memcached_string_t hostname= { memcached_string_make_from_cstr(list[x].hostname) };
!     if (__instance_create_with(ptr, instance, 
                                 hostname,
                                 list[x].port(), list[x].weight, list[x].type) == NULL)
      {
--- 486,492 ----
      WATCHPOINT_ASSERT(instance);
  
      memcached_string_t hostname= { memcached_string_make_from_cstr(list[x].hostname) };
!     if (__instance_create_with(ptr, instance,
                                 hostname,
                                 list[x].port(), list[x].weight, list[x].type) == NULL)
      {
*** libmemcached-1.0.13-vanilla/libmemcached/is.h	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/libmemcached/is.h	2012-10-22 22:48:11.717010265 -0700
***************
*** 1,5 ****
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  * 
   *  LibMemcached
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
--- 1,5 ----
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  *
   *  LibMemcached
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
***************
*** 37,43 ****
  
  #pragma once
  
! /* These are private */ 
  #define memcached_is_allocated(__object) ((__object)->options.is_allocated)
  #define memcached_is_encrypted(__object) ((__object)->hashkit._key)
  #define memcached_is_initialized(__object) ((__object)->options.is_initialized)
--- 37,43 ----
  
  #pragma once
  
! /* These are private */
  #define memcached_is_allocated(__object) ((__object)->options.is_allocated)
  #define memcached_is_encrypted(__object) ((__object)->hashkit._key)
  #define memcached_is_initialized(__object) ((__object)->options.is_initialized)
***************
*** 48,53 ****
--- 48,54 ----
  #define memcached_is_udp(__object) ((__object)->flags.use_udp)
  #define memcached_is_verify_key(__object) ((__object)->flags.verify_key)
  #define memcached_is_binary(__object) ((__object)->flags.binary_protocol)
+ #define memcached_is_ramcloud(__object) ((__object)->flags.ramcloud_protocol)
  #define memcached_is_fetching_version(__object) ((__object)->flags.is_fetching_version)
  #define memcached_is_buffering(__object) ((__object)->flags.buffer_requests)
  #define memcached_is_replying(__object) ((__object)->flags.reply)
*** libmemcached-1.0.13-vanilla/libmemcached/memcached.cc	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/libmemcached/memcached.cc	2012-11-01 15:59:09.039824572 -0700
***************
*** 1,5 ****
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  * 
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
--- 1,5 ----
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  *
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
***************
*** 49,54 ****
--- 49,55 ----
  
    self->flags.auto_eject_hosts= false;
    self->flags.binary_protocol= false;
+   self->flags.ramcloud_protocol= false;
    self->flags.buffer_requests= false;
    self->flags.hash_with_namespace= false;
    self->flags.no_block= false;
***************
*** 241,247 ****
    {
      rc= memcached_parse_configure_file(*memc, memcached_parse_filename(memc), memcached_parse_filename_length(memc));
    }
!     
    if (memcached_failed(rc))
    {
      memcached_free(memc);
--- 242,248 ----
    {
      rc= memcached_parse_configure_file(*memc, memcached_parse_filename(memc), memcached_parse_filename_length(memc));
    }
! 
    if (memcached_failed(rc))
    {
      memcached_free(memc);
***************
*** 337,342 ****
--- 338,350 ----
    new_clone->dead_timeout= source->dead_timeout;
    new_clone->distribution= source->distribution;
  
+   //TODO(RAMCloud) I'm going to blindly copy over data, but a question that
+   // comes up is... are the RAMCloud calls thread safe for each rc_client? 
+   // Assume not and just make a new one here??
+   new_clone->ramcloud = source->ramcloud;
+   new_clone->tableId = source->tableId;
+ 
+ 
    if (hashkit_clone(&new_clone->hashkit, &source->hashkit) == NULL)
    {
      memcached_free(new_clone);
*** libmemcached-1.0.13-vanilla/libmemcached/parse.cc	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/libmemcached/parse.cc	2012-10-23 01:34:28.172046235 -0700
***************
*** 1,5 ****
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  * 
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
--- 1,5 ----
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  *
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
***************
*** 35,42 ****
   *
   */
  
! /* 
!   I debated about putting this in the client library since it does an 
    action I don't really believe belongs in the library.
  
    Frankly its too damn useful not to be here though.
--- 35,42 ----
   *
   */
  
! /*
!   I debated about putting this in the client library since it does an
    action I don't really believe belongs in the library.
  
    Frankly its too damn useful not to be here though.
***************
*** 56,63 ****
  
    end_ptr= server_strings + strlen(server_strings);
  
!   for (begin_ptr= server_strings, string= (char *)index(server_strings, ','); 
!        begin_ptr != end_ptr; 
         string= (char *)index(begin_ptr, ','))
    {
      char buffer[HUGE_STRING_LEN];
--- 56,63 ----
  
    end_ptr= server_strings + strlen(server_strings);
  
!   for (begin_ptr= server_strings, string= (char *)index(server_strings, ',');
!        begin_ptr != end_ptr;
         string= (char *)index(begin_ptr, ','))
    {
      char buffer[HUGE_STRING_LEN];
***************
*** 108,110 ****
--- 108,124 ----
  
    return servers;
  }
+ 
+ /**
+  * Assumes 1 server only. Don't break this assumption or I will hunt you down.
+  */
+ memcached_server_list_st ramcloud_servers_parse(const char *server_strings)
+ {
+   memcached_server_st *servers= NULL;
+   memcached_return_t rc;
+ 
+   WATCHPOINT_ASSERT(server_strings);
+ 
+   return memcached_server_list_append(servers, server_strings, 0, &rc);
+ 
+ }
*** libmemcached-1.0.13-vanilla/libmemcached/storage.cc	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/libmemcached/storage.cc	2012-10-24 03:22:47.497810326 -0700
***************
*** 1,5 ****
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  * 
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
--- 1,5 ----
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  *
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
***************
*** 37,42 ****
--- 37,43 ----
  
  
  #include <libmemcached/common.h>
+ #include <CRamCloud.h>
  
  enum memcached_storage_action_t {
    SET_OP,
***************
*** 83,89 ****
    case CAS_OP:
    case REPLACE_OP:
      return true;
!     
    case APPEND_OP:
    case PREPEND_OP:
      break;
--- 84,90 ----
    case CAS_OP:
    case REPLACE_OP:
      return true;
! 
    case APPEND_OP:
    case PREPEND_OP:
      break;
***************
*** 261,267 ****
    int flags_buffer_length= snprintf(flags_buffer, sizeof(flags_buffer), " %u", flags);
    if (size_t(flags_buffer_length) >= sizeof(flags_buffer) or flags_buffer_length < 0)
    {
!     return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT, 
                                 memcached_literal_param("snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)"));
    }
  
--- 262,268 ----
    int flags_buffer_length= snprintf(flags_buffer, sizeof(flags_buffer), " %u", flags);
    if (size_t(flags_buffer_length) >= sizeof(flags_buffer) or flags_buffer_length < 0)
    {
!     return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,
                                 memcached_literal_param("snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)"));
    }
  
***************
*** 269,275 ****
    int expiration_buffer_length= snprintf(expiration_buffer, sizeof(expiration_buffer), " %llu", (unsigned long long)expiration);
    if (size_t(expiration_buffer_length) >= sizeof(expiration_buffer) or expiration_buffer_length < 0)
    {
!     return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT, 
                                 memcached_literal_param("snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)"));
    }
  
--- 270,276 ----
    int expiration_buffer_length= snprintf(expiration_buffer, sizeof(expiration_buffer), " %llu", (unsigned long long)expiration);
    if (size_t(expiration_buffer_length) >= sizeof(expiration_buffer) or expiration_buffer_length < 0)
    {
!     return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,
                                 memcached_literal_param("snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)"));
    }
  
***************
*** 277,283 ****
    int value_buffer_length= snprintf(value_buffer, sizeof(value_buffer), " %llu", (unsigned long long)value_length);
    if (size_t(value_buffer_length) >= sizeof(value_buffer) or value_buffer_length < 0)
    {
!     return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT, 
                                 memcached_literal_param("snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)"));
    }
  
--- 278,284 ----
    int value_buffer_length= snprintf(value_buffer, sizeof(value_buffer), " %llu", (unsigned long long)value_length);
    if (size_t(value_buffer_length) >= sizeof(value_buffer) or value_buffer_length < 0)
    {
!     return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,
                                 memcached_literal_param("snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)"));
    }
  
***************
*** 288,294 ****
      cas_buffer_length= snprintf(cas_buffer, sizeof(cas_buffer), " %llu", (unsigned long long)cas);
      if (size_t(cas_buffer_length) >= sizeof(cas_buffer) or cas_buffer_length < 0)
      {
!       return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT, 
                                   memcached_literal_param("snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)"));
      }
    }
--- 289,295 ----
      cas_buffer_length= snprintf(cas_buffer, sizeof(cas_buffer), " %llu", (unsigned long long)cas);
      if (size_t(cas_buffer_length) >= sizeof(cas_buffer) or cas_buffer_length < 0)
      {
!       return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,
                                   memcached_literal_param("snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)"));
      }
    }
***************
*** 315,326 ****
    // If we should not reply, return with MEMCACHED_SUCCESS, unless error
    if (reply == false)
    {
!     return memcached_success(rc) ? MEMCACHED_SUCCESS : rc; 
    }
  
    if (flush == false)
    {
!     return memcached_success(rc) ? MEMCACHED_BUFFERED : rc; 
    }
  
    if (rc == MEMCACHED_SUCCESS)
--- 316,327 ----
    // If we should not reply, return with MEMCACHED_SUCCESS, unless error
    if (reply == false)
    {
!     return memcached_success(rc) ? MEMCACHED_SUCCESS : rc;
    }
  
    if (flush == false)
    {
!     return memcached_success(rc) ? MEMCACHED_BUFFERED : rc;
    }
  
    if (rc == MEMCACHED_SUCCESS)
***************
*** 350,355 ****
--- 351,358 ----
    return rc;
  }
  
+ 
+ 
  static inline memcached_return_t memcached_send(memcached_st *ptr,
                                                  const char *group_key, size_t group_key_length,
                                                  const char *key, size_t key_length,
***************
*** 360,365 ****
--- 363,386 ----
                                                  memcached_storage_action_t verb)
  {
    memcached_return_t rc;
+ 
+   /**
+    * First so that it bypasses all other junk that occurs below
+    */
+   //TODO(RAMCloud) this is not a generic verb, but it is all types of insert
+   if(memcached_is_ramcloud(ptr)) {
+       //TODO(RAMCloud) some CAS rules could be implemented via RejectRules
+       RejectRules rr;
+       uint64_t version;
+       Status s = rc_write(ptr->ramcloud, ptr->tableId, key, key_length, value,
+               value_length, NULL, &version);
+ 
+       if ( s == STATUS_OK)
+           return MEMCACHED_SUCCESS;
+ 
+       return MEMCACHED_WRITE_FAILURE;
+   }
+ 
    if (memcached_failed(rc= initialize_query(ptr, true)))
    {
      return rc;
***************
*** 391,397 ****
    {
      if (can_by_encrypted(verb) == false)
      {
!       return memcached_set_error(*ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT, 
                                   memcached_literal_param("Operation not allowed while encyrption is enabled"));
      }
  
--- 412,418 ----
    {
      if (can_by_encrypted(verb) == false)
      {
!       return memcached_set_error(*ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,
                                   memcached_literal_param("Operation not allowed while encyrption is enabled"));
      }
  
*** libmemcached-1.0.13-vanilla/libmemcached-1.0/struct/memcached.h	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/libmemcached-1.0/struct/memcached.h	2012-10-23 03:35:18.451004332 -0700
***************
*** 1,5 ****
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  * 
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
--- 1,5 ----
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  *
   *  Libmemcached library
   *
   *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
***************
*** 66,73 ****
--- 66,80 ----
      bool is_aes:1;
      bool is_fetching_version:1;
      bool not_used:1;
+     bool ramcloud_protocol:1;
    } flags;
  
+   struct rc_client *ramcloud;
+   uint64_t tableId;
+   //TODO(RAMCloud) I've searched for a long time on how to find how they load up
+   // values and I couldn't find it, so I created my own buffer in here
+   char value[1024*1024];
+ 
    memcached_server_distribution_t distribution;
    hashkit_st hashkit;
    struct {
*** libmemcached-1.0.13-vanilla/libmemcached-1.0/types/behavior.h	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/libmemcached-1.0/types/behavior.h	2012-10-22 22:53:08.496046279 -0700
***************
*** 1,8 ****
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  * 
   *  Libmemcached library
   *
!  *  Copyright (C) 2011 Data Differential, http://datadifferential.com/ 
   *  All rights reserved.
   *
   *  Redistribution and use in source and binary forms, with or without
--- 1,8 ----
  /*  vim:expandtab:shiftwidth=2:tabstop=2:smarttab:
!  *
   *  Libmemcached library
   *
!  *  Copyright (C) 2011 Data Differential, http://datadifferential.com/
   *  All rights reserved.
   *
   *  Redistribution and use in source and binary forms, with or without
***************
*** 58,63 ****
--- 58,64 ----
    MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED,
    MEMCACHED_BEHAVIOR_KETAMA_HASH,
    MEMCACHED_BEHAVIOR_BINARY_PROTOCOL,
+   MEMCACHED_BEHAVIOR_RAMCLOUD_PROTOCOL, 
    MEMCACHED_BEHAVIOR_SND_TIMEOUT,
    MEMCACHED_BEHAVIOR_RCV_TIMEOUT,
    MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT,
*** libmemcached-1.0.13-vanilla/libmemcached-1.0/parse.h	2012-10-18 18:55:09.000000000 -0700
--- libmemcached-1.0.13/libmemcached-1.0/parse.h	2012-10-23 00:11:57.190004172 -0700
***************
*** 17,22 ****
--- 17,23 ----
  
  LIBMEMCACHED_API
  memcached_server_list_st memcached_servers_parse(const char *server_strings);
+ memcached_server_list_st ramcloud_servers_parse(const char *server_strings);
  
  #ifdef __cplusplus
  }
*** libmemcached-1.0.13-vanilla/Makefile	2012-12-26 12:55:01.000000000 -0800
--- libmemcached-1.0.13/Makefile	2012-11-02 05:50:19.000000000 -0700
***************
*** 1493,1499 ****
  CXX = /usr/bin/g++
  CXXCPP = /usr/bin/g++ -E
  CXXDEPMODE = depmode=gcc3
! CXXFLAGS =  -g -O2 -D_FORTIFY_SOURCE=2 -Wno-pragmas -Wall -Wextra -Wunknown-pragmas --param=ssp-buffer-size=1 -Waddress -Warray-bounds -Wchar-subscripts -Wcomment -Wctor-dtor-privacy -Wfloat-equal -Wformat=2 -Wmissing-field-initializers -Wmissing-noreturn -Wlogical-op -Wnon-virtual-dtor -Wnormalized=id -Woverloaded-virtual -Wpointer-arith -Wredundant-decls -Wshadow -Wsign-compare -Wstrict-overflow=1 -Wswitch-enum -Wundef -Wunused-variable -Wwrite-strings -Wformat-security -fwrapv
  CXX_VERSION = g++ (GCC) 4.4.6 20110731 (Red Hat 4.4.6-3)
  CYGPATH_W = echo
  DEFS = -DHAVE_CONFIG_H
--- 1493,1499 ----
  CXX = /usr/bin/g++
  CXXCPP = /usr/bin/g++ -E
  CXXDEPMODE = depmode=gcc3
! CXXFLAGS =  -g -O2 -D_FORTIFY_SOURCE=2 -Wno-pragmas -Wall -Wextra -Wunknown-pragmas --param=ssp-buffer-size=1 -Waddress -Warray-bounds -Wchar-subscripts -Wcomment -Wctor-dtor-privacy -Wfloat-equal -Wformat=2 -Wmissing-field-initializers -Wmissing-noreturn -Wlogical-op -Wnon-virtual-dtor -Wnormalized=id -Woverloaded-virtual -Wpointer-arith -Wredundant-decls -Wshadow -Wsign-compare -Wstrict-overflow=1 -Wswitch-enum -Wundef -Wunused-variable -Wwrite-strings -Wformat-security -fwrapv -I/home/syang0/ramcloud/src -lramcloud -L/home/syang0/ -lstdc++ -lpcrecpp -lprotobuf -libverbs -lrt
  CXX_VERSION = g++ (GCC) 4.4.6 20110731 (Red Hat 4.4.6-3)
  CYGPATH_W = echo
  DEFS = -DHAVE_CONFIG_H
